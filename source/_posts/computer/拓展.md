---
title: 什么是信息
date: 2022-06-17 08:23:10
tags: 科普
categories: computer
---
# 信息篇

## 什么是信息

### 摩尔定律

![](https://raw.githubusercontent.com/wyf195075595/images/main/blog/%E6%91%A9%E5%B0%94%E5%AE%9A%E5%BE%8B.png)

<!--more-->

### 信息

```                      
1、什么是信息？
信息是事物运动状态或存在方式的 不确定性 的描述---（香农【通信的数学理论】）

2、信息熵
	信息和长度，重量这些物理属性一样，也可以测量和规范 。 单位 比特（bit）
```

<img src="https://raw.githubusercontent.com/wyf195075595/images/main/blog/%E4%BF%A1%E6%81%AF%E7%86%B5.png" style="zoom:75%;" />



```js
1）. p(xi) 表示消息xi发生的概率
2）. -log2p(xi) 表示消息xi所包含的信息量
3）. E[i=1, n] 每个消息的信息量乘上它发生的概率后再求总和，得到的是从一个信息源发出的各个消息所包含的平均信息量
4）. H 是所有消息的平均不确定性
```

<img src="https://raw.githubusercontent.com/wyf195075595/images/main/blog/%E6%8A%9B%E7%A1%AC%E5%B8%81.png" style="zoom:75%;" />

```
每条信息平均信息量为 1

结果1表示 至少需要1个 [1/0] 来表示结果

结论：
-一切信源发出的消息或者信号都可以用0和1的组合来描述
-信息从一种形式转换为另一种形式的过程，我们称之为编码
-具体需要用多少个 0/1 来编码取决于信息熵的大小




```

### 信息处理

```
虽然信息是复杂多样的，但我们都可以用 0/1 这两个符号组合起来来编码。 对编码后的 0/1 构成的符号串进行变化，加工 就是我们常说的 "信息处理"
```

### 计算的本质

```
从一个 0/1 符号串到另一个 0/1 符号串的变换
```

### 为啥只用 0、1来进行编码？

```js
1. 进制
进位计数制的简称，指计数的方法，一般用于刻画事物之间的数量关系，是人们在长期实践中发现和发明的。

-十进制
	0 1 2 3 4 5 6 7 8 9
	// eg: 365.32
	3	 	6		5		.3		2
	10^2	10^1	10^0	10^-1	10^-2
=   3*100+ 6*10+ 5*0 + 3*10^-1 + 2*10^-2

10 [十进制的基数] （逢十进一，相传是人有十指的缘故）


定义进制 R
1、定义 技术的基数 R，和R 个基本符号，我们就定义了一个R进制。对于R进制而言，运算规则 逢R进1


十进制/二进制
1、任何一个数都可以用不同的进位制表示

    十进制	二进制	八进制	十六进制
    14	  1110   16    E
2、任何一个进制的表示都可以通过"按权展开" 的方式转换为十进制数
	（1001）二 = 2^3 + 2^0 = (9)十	
    （1001）八 = 8^3 + 8^0 = (513)十
    
    
一百零一页报告（冯诺依曼）中明确指出 使用二进制的优越性
...



-基于二进制的运算规则简单，简化设计
-需要实现的物理状态单一，系统可靠性和稳定性高
-适合实现逻辑运算，通用性高

```

### 算数与逻辑运算

```js
1、CPU 算术逻辑运算器(ALU) 
	既能处理算数运算（四则运算），又能处理逻辑运算
    
2、算数运算
```

![](https://raw.githubusercontent.com/wyf195075595/images/main/blog/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BF%90%E7%AE%97%E8%A7%84%E5%88%99.png)

```js
3、逻辑运算
	-逻辑运算又称为布尔运算
	-运算结果为布尔值 	

丰富了程序结构，是实现分支，循环的基本要素
```

| 基本运算  | 运算符 | 语义 |
| --------- | ------ | ---- |
| 与（and） | ^      | 或者 |
| 或（or）  | ∨      | 并且 |
| 非（not） | ﹁     | 除非 |

<img src="https://raw.githubusercontent.com/wyf195075595/images/main/blog/%E7%9C%9F%E5%80%BC%E8%BF%90%E7%AE%97%E8%A1%A8.png" style="zoom:75%;" />

```
异或运算（XOR）运算符 ⊕
```

<img src="https://raw.githubusercontent.com/wyf195075595/images/main/blog/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97.png" style="zoom:75%;" />

```js
4、位运算
-对给定的两个等长的0/1符号串，从左到右按位对齐，逐一对每一位进行布尔运算
	-与
	-或
	-异或
-对于单个定长的0/1符号串，根据应用的需求施加位运算
	-非
	-左移位
	-右移位
```

十进制与二进制的转换

```js
1、任意R进制-》十进制
	-按权展开

2、十进制转二进制
	-整数部分：除2取余法（余数法）
        -整数除以2之后留取余数作为结果
	-小数部分：乘以2取整法（进位法）
		-小数乘以2之后留取整数部分作为结果.
```

<img src="https://raw.githubusercontent.com/wyf195075595/images/main/blog/%E5%8F%96%E4%BD%99%E6%B3%95.png" style="zoom:75%;" />

<img src="https://raw.githubusercontent.com/wyf195075595/images/main/blog/%E8%BF%9B%E4%BD%8D%E6%B3%95.png" style="zoom:75%;" />

### 计算机的局限性

```js
-数学思维的世家是连续的，无限的

-计算思维的世界是离散的，有限的

eg:
	0.64(十) -> ？（二）
	会出现无限循环，然而真实的计算机储存内力是有限的
    
    

```

### 计量单位

| 名称/简称 | 本意       | 计算机科学         |
| --------- | ---------- | ------------------ |
| KILO (K)  | 千(10^3)   | 1K = 2^10 = 1024   |
| Mega (M)  | 百万(10^6) | 1M = 10^20 = 1024K |
| Giga (G)  | 10^9       | 1G = 2^30 = 1024M  |
| Tera (T)  | 10^12      | 1T = 2^40 = 1024G  |
| Peta (P)  | 10^15      | 1P = 2^50 = 1024T  |
| Eax (E)   | 10^18      | 1E = 2^60 = 1024P  |

> 11位的十进制数 可以用34位二进制表示
>
> 2^33 = 2^30*2^3 ≈ 10^9 * 10 = 10^10

### 位的概念

```
比特 （bit ,Binary dight）
- 0/1 信息编码中的一位
- 信息量的最小度量单位
- 缩写为 b

首次提出 John Wide Tukey (美国数学家)
首次使用 通信的数学理论 （香农）
```

### 字节的概念

```js
字节 （Byte）
- 缩写为 B
- 1个字节由8位组成
- 1字节等于8比特 （1B = 8b）

eg:
8G 内存条实际容量： 8*2^30B
```

### 计算机中如何区分正负数

```js
-机器数
	将真值的正负符号数值化，用0表示正，用1表示负
-真值
	带有 "+","-"号的数据表示
    
```

| 真值       | 机器数      |
| ---------- | ----------- |
| N1 = +1101 | N1 = 0 1101 |
| N2 = -1101 | N2 = 1 1101 |

### 数值信息的编码 - 原码

```js
-符号部分
	数的最高位为 "符号位"
	用代码 0 表示 "+", 用代码 1 表示 "-"
-数值部分与真值相同
-与 "位模式" 的关系

                    N位源码
    符号 ...... B5 B4 B3 B2 B1 B0
    
    N 位模式下，数值部分不足N-1位，则用0补足
    
不足：
	运算复杂
    1、要对符号和数值的绝对值大小进行判断
    
    
能否有一种编码不考虑符号位直接进行加减运算？
```

### 补码

```js
  为了简化加减运算，也为了使编码表示更加精准，引进新的机器数的形式。

-符号部分同原码
	最高位为符号位，0 表示正数，1表示负数
-数值部分与它的符号位有关
	对于正数, 补码的数值部分与源码相同
	对于负数，是将原码数值部分按位取反再加1

源码与补码的相互转化都是通过 取反加1的操作完成的

补码解决了源码 0 有两种形式的问题，实现了数值的一一对应

补码的运算
	-符号位参加计算，忽略进位
	

// 同余理论
	-两个整数a, b,若他们除以整数m所得的余数相等。则称a,b对于整数m同余， m称为 模 ，记作 a ≡ b (mod in) 读作 a与 b 关于模 m 同余
                                                     
// 同余理论的推论：
                                                         在模为M的条件下， A-B，可以用A加上-B的补数来实现
                                                         求 -B 的补数的公式：
        
        -B的补数 = -B + M                                                     
    eg: 从6点调到4点
                                                             顺 6 + 10
                                                             逆 6 - 2
                                                             （6 - 2）mod 12 = 4
                                                             （6 + 10）mod 12 = 16 -12 = 4
                                                             10 是 -2 的补数
                                                   
                                                      // 8 位补码表示与 模 的关系
                                                             无符号（11111111）2进制 = （255）10进制
                                                             255 = -1 + 256
                                                             求 -B 的补数的公式：
        
        -B的补数 = -B + M       
                                                              [-1]补 = (-1)mod256
    
    	补码的定义：
        	[x]补 = (2^n + x) mod 2^n
			n: 表示 n位位模式确定的模
            
 // 补码的运算规则
      -两数和的补码等于两数补码的和
      [x1 + x2]补 = [x1]补 + [x2]补      
      [x1 - x2]补 = [x1]补 + [-x2]补
      
      -只需要一套实现加法运算的器件，从而简化了计算机内部硬件电路的结构
```

![]()<img src="https://raw.githubusercontent.com/wyf195075595/images/main/blog/%E8%A1%A5%E7%A0%81.png" alt="补码" style="zoom:75%;" />

补码与源码的差异

<img src="https://raw.githubusercontent.com/wyf195075595/images/main/blog/%E8%A1%A5%E7%A0%81%E4%B8%8E%E5%8E%9F%E7%A0%81.png" style="zoom:75%;" />

8位位模式补码表示范围

<img src="https://raw.githubusercontent.com/wyf195075595/images/main/blog/8%E4%BD%8D%E8%A1%A5%E7%A0%81%E8%A1%A8%E7%A4%BA%E8%8C%83%E5%9B%B4.png" style="zoom:75%;" />

```
推论：

n 位：
	范围：[-2^(n-1), +2^(n-1) - 1]
	个数：2^n 个

```

### 补码运算的溢出问题

```js
两个数参加运算，结果超出了机器能表示的数的范围，称之"溢出"

1、正溢出
	加数和被加数的符号为"0"，加完后结果的符号为"1"的情况,称为"正溢出”

eg: 5位二进制补码表示数
	A：+1100， B：+0110，求A+B
	解：[A]十 = 12， [B]十 = 6, [A]十+[B]十=18
    	[A+B]补 = A补 + B补
		A补 = 01100，B补 = 00110
		A + B = -1110
	然而5位补码表示范围为[-2^4, +2^4-1] = [-16, +15]

2、负溢出
	加数和被加数的符号位为"1"，加完之后结果的符号位为"0"的情况，称为"负溢出"

eg: 5位二进制补码表示数
	A：-1101， B：-1010，求A+B
	解：[A]十 = -13， [B]十 = -10, [A]十+[B]十=-23
    	[A+B]补 = A补 + B补
		A补 = 10011，B补 = 10110
		A + B = +1001
	然而5位补码表示范围为[-2^4, +2^4-1] = [-16, +15]
```

### 定点数与浮点数

```js
根据小数点的位置是否固定，数据有"定点数"和"浮点数"两种表达方式

1、定点
	：约定机器中所有数据的小数点位置固定不变
    -"小数点"变为隐含信息，不需要表示
    -数符和数值部分的编码方式既可以用"原码"也可以用"补码"
	-用定点数进行运算处理的计算机被称之为定点机
    
定点格式只能表示整数或是纯小数
```

<img src="https://raw.githubusercontent.com/wyf195075595/images/main/blog/%E5%AE%9A%E7%82%B9%E6%95%B0.png" style="zoom:75%;" />

```js
2、浮点数
	-一个数N的科学计数法形式可写成：N = M*R^E
		▪尾数M,通常是小数
		▪阶码E，通常是整数
        
   eg: 26.375 = 2.6375*10^1

	-当尾数，阶码采用二进制，基数R = 2时，就是计算机中的浮点数据表示
    
	-浮点表示格式
    ▪尾数：定点小数表示，决定了浮点数的表示精度
    ▪阶码：定点整数表示，决定了浮点数的表示范围
    
	-为了不损失有效数字，常对尾数进行规格化处理
		▪规格化对尾数M的要求：1/2<= |M| < 1
		▪即保证尾数部分真值的最高位是1，大小通过阶码调整
        
   【注意】下图中的阶码是以二进制显示的
```



<img src="https://raw.githubusercontent.com/wyf195075595/images/main/blog/%E6%B5%AE%E7%82%B9%E6%95%B0%E8%A1%A8%E7%A4%BA.png" style="zoom:75%;" />

### 小数需要表示吗

```js
▪由于规则的约定小数点变成了交互双方的一个默认信息而无需表示
	-信息论的解释：表示小数点的信息熵为0
▪定点表示和浮点表示的优缺点
	-定点表示法运算直观，但数的表示范围较小
	-浮点表示法表示的数范围和精度都有提升，但是浮点运算复杂
```

### 定点与浮点的实现

```js
▪定点机
	-CPU被设计为执行定点算术运算，通过分解运算序列，使用定点架构来实现浮点单元
▪浮点运算单元（FPU）
	-对浮点数执行+,-,*,//,平方根和位移等操作
```

### 关于多媒体信息表示

```
▪数值信息与非数值信息
-数值
-字符
-声音
-图像
-视频
-动画
▪建立抽象与具象的连接
```

## 字符信息的编码

### ASCII码

```js
美国信息交换标准代码（American Standard Code for Information Interchange, ASCII）
▪国际标准： ISO 646标准，适用于拉丁文字字母
▪首发在1967年，最后一次更新在1986年

-ASCII 码的拓展 （其他国家文字多，不够用）
▪利用ASCII码中闲置的最高位编入新的符号，最多可表示256个符号

▪0-127保持不变， 128-255为扩展段
    eg: 编码： 10000010 =》 130 表示 é
    
▪ASCII码不适用于亚洲文字
	-国标码 GB2312
		.用2个字节表示一个汉字
			至少13位二进制编码，考虑扩充设置14
			14位需2个字节保存，每个字节最高位设为0
			
		.最多可表示65536个字符
	-国标码与机内码的关系
		.ASCII和国标码并存出现二义性
		 //国标码每个字节的最高位置为1，机内码=国标码+8080H

		eg:
			"啊" 国标码：3021H
                  机内码：3021H + 8080H = B0A1H
		
【】计算机处理和显示不同的文符文字，必须适配不同的编码规则
```

![](https://raw.githubusercontent.com/wyf195075595/images/main/blog/ascii.png)

### Unicode

```js
.Unicode又称统一码，万国码，单一码
.世界上所有语言的符号，组成通用字符集

-Unicode编码由4个字节组成
-Unicode编码体系具有较复杂的"立体"结构
```

### 

## 数字音频及其处理

```js
▪声音
	在介质中传播的机械波，是随时间连续变化的连续信号
    
计算机不能直接记录模拟信号


-采样频率
    单位时间内采样的次数， 单位：赫兹（Hz）
    采样周期 = 1/采样频率
    eg: 一秒钟取十次样本，即采样频率 10Hz
    ▪频率越高，质量越好，数据量也越大    
    ▪例子：固定电话采用8kHz,网络歌曲常采用44.1kHz
-量化位数（也称采样精度）
    ▪每个采样点的二进制位数，单位：位/字节
    ▪eg: 固定电话常采用8位,网络歌曲常采用16位
-声道数
	▪包含声道的个数
    ▪例：固定电话常为1声道，网络歌曲常为2声道
    
    
 -比特率
    ▪单位时间的比特数，单位：比特/秒（bps）
    ▪采样频率*量化位数*声道数
    ▪比特率*持续时间（秒） = 数据量（比特）
```

<img src="https://raw.githubusercontent.com/wyf195075595/images/main/blog/%E9%9F%B3%E9%A2%91%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7.png" style="zoom:75%;" />

```js
// 声音数字化过程

1、采样
	对时间进行离散化
    
```

<img src="https://raw.githubusercontent.com/wyf195075595/images/main/blog/%E7%A6%BB%E6%95%A3%E5%8C%96.png" style="zoom:75%;" />

```js
2、量化
	对振幅值进行限定和近似的过程
    
    量化会产生一定的误差，但只要通过增加量化等级的数量或者说 缩小等级之间的间距
    
    比如： 0.11 用 0.1表示
    	  0.9 用 0.2 表示
```

<img src="https://raw.githubusercontent.com/wyf195075595/images/main/blog/%E9%87%8F%E5%8C%96.png" style="zoom:75%;" />

```js
3、编码
	
▪将量化后的振幅用二进制表示
```

<img src="https://raw.githubusercontent.com/wyf195075595/images/main/blog/%E7%BC%96%E7%A0%81.png" style="zoom:75%;" />

### 数据压缩

```js
原理：对原始数据进行重新编码，去除原始数据中的 冗余数据（重复的数据）


eg: AAAAAAAAAACCCCCCCBBBBBBBBCCCCC -> 10A7C8B5C （行程编码）
▪如果采用ASCII码，原始数据占多少字节？ 30B
▪如果一个整数站2B， 压缩数据占多少字节？ 12B
▪压缩比： 压缩前后的数据量之比          = 2.5：1

-解压缩
	与压缩方式相反
    ▪无损压缩（或可你压缩）
    	被压缩的数据经过解压缩后，可以得到与原始数据完全相同的数据
     	常用于对信息还原要求较高的压缩：如 文件的压缩
    ▪有损压缩
    	被压缩后的数据经过解压缩后,不能得到与原始数据完全相同的数据
		例如：音视频，图片的压缩
    
```

## 数字图像



```js
1、图像分辨率
	（x，y）用来描述图片的宽，高 单位像素
    
2、像素坐标
    ▪从图片的左上角建立坐标系
    ▪(x,y): 从左往右数第x个，从上往下数第y个
    ▪x,y 从0开始
    
    
3、操作像素
	▪像素中存储的是颜色值 （x,y,z）【RGB格式】

4、颜色的表示
	▪量化：将自然界无数种颜色限定到有限个取值范围内
    
```

![]()<img src="https://raw.githubusercontent.com/wyf195075595/images/main/blog/%E5%8D%95%E8%89%B2%E5%9B%BE%E5%83%8F.png" alt="单色图像" style="zoom:75%;" />

<img src="https://raw.githubusercontent.com/wyf195075595/images/main/blog/%E7%81%B0%E5%BA%A6%E5%9B%BE%E5%83%8F.png" style="zoom:75%;" />

```js
5、像素深度（位深度）
	▪每个像素颜色所使用的二进制数
    
    如上图灰度图像，划分了16层。 白色用 1111 表示，黑色用 0000 表示
    刚好16种。 使用了4位二进制数，所以它的像素深度为4 可以表示 2^4 = 16种颜色
    
6、RGB颜色模型
    ▪自然界任何颜色都可以由红、绿、蓝 三种基本颜色按一定比例组合而成
    ▪亮度越大，比例越高，反之越低
    ▪ 每个颜色有 256 种，总共可表示 256*256*256=16777216种颜色
    ▪像素深度 8*3=24位
    

    -MBP格式图片
    	▪不进行数据压缩，数据量大，但质量好
        eg: 一副 BMP 格式的真彩色图像的分辨率为 3648*2736，其数据量为？
        解：
        	像素点存储一个RGB颜色值，占 3*8=24b(比特)= 3B(字节)
            3648*2736*3 （B）			
            3648*2736*3/1024 （KB）
            3648*2736*3/1024/1024≈28.5 （M
            
   -jpg
	▪有损压缩，压缩比5：1 ~ 50：1， 而且质量较好
    ▪不支持透明度
    
7、RGBA颜色
	▪A分量： 透明度，取值[0,255]
		0 完全透明
        255 完全不透明
        
8、绿幕抠像的原理
	-将绿幕部分像素设置成完全透明，非绿幕部分保持不变
    ▪根据像素 是否偏绿 来设置透明图
```

<img src="https://raw.githubusercontent.com/wyf195075595/images/main/blog/likegreen.png" style="zoom:75%;" />

```
小结： 
	现实场景 
	--采样-->  将空间上无限个点变成有限个像素 
	--量化--> 将自然界颜色离散化 为有限种颜色表示 
	--编码--> 用二进制数据表示量化后的颜色  
```



## 信息小结

![](https://raw.githubusercontent.com/wyf195075595/images/main/blog/msgAndcode.png)

# 程序员视角

## 什么是计算？

> 从 一个符号串 变换成另一个 符号串 -- Peter J.Denning

## 计算过程

> 从初始符号或已知符号开始，一步步地变换符号，经过有限步骤，最后得到一个满足预先规定的符号串的变换过程

## 图灵机

```
-一条两头可以无限延伸的纸带
-一个读写头
-一个控制器

▪通用性
	-数据的多样性
	-程序的多样性
	
通用计算机装置应具备 符号解译， 过程记忆 以及 可编程 的能力

计算装置的构成
	◉输入部件
	◉运算单元
	◉储存器
	◉控制器
	◉输出部件
```

## 冯诺依曼结构体系

```
1946年，第一台计算机（ENIAC）的问世，却有着巨大的缺陷，没有存储单元


-一百零一页报告
	存储程序控制原理：把程序本身当作数据来对待，程序与其要处理的数据一样用同样的方式储存
	
	
1949年5月， EDVAC
	世界上第一台真正实现内部储存程序的电子计算机
	
	
冯氏结构的实现
	
	输入设备（鼠标，键盘）
	输出设备（显示器）
	控制器/运算器（CPU）
	存储器（内存条主存）
	主板（总线， 输入输出的接口）
	
现代计算机储存系统
    内存 （内存储器）
    外存 （联机外存【硬盘】，脱机外存【U盘，光盘】）
    

```

|                    | 内存 | 外存 |
| ------------------ | ---- | ---- |
| 是否能长期保存数据 | 否   | 是   |
| 速度               | 快   | 慢   |
| 容量               | 小   | 大   |
| 价格               | 高   | 低   |

![]()<img src="https://raw.githubusercontent.com/wyf195075595/images/main/blog/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84.png" alt="冯诺依曼结构" style="zoom:75%;" />

<img src="https://raw.githubusercontent.com/wyf195075595/images/main/blog/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%85%B8%E5%9E%8B%E7%BB%93%E6%9E%84.png" style="zoom:75%;" />

## 冯氏结构软件模拟

> 程序 是指为完成一项特定任务，用计算机语言描述的问题求解步骤的有序 序列

```js
▪程序和数据都是用0/1形式表示，0/1编码称为机器语言

▪指令：用机器语言描述的计算机执行的最小单位
	-指令格式： 
         操作码（指令的功能）
         操作数（操作的对象）
	-指令类型： 
		操作指令
		数据移动指令
		控制指令

▪机器语言程序：由一组有序的指令组成的指令序列

▪CPU所能执行的机器指令集合，称之为 指令集 或者 指令系统

▪任何 程序 都是由指令集和内不同指令 组合 而成的 指令序列

eg: 例如 AMD， Inter 都支持指令集 X86的指令集（部分）



因为原生的计算机语言不方便程序员的阅读，开发。于是诞生了 汇编语言

▪用一些容易理解和记忆的字母，单词来代替一个特定的指令中的0/1编码

eg：
	助记符		含义
	ADD -> 数字逻辑上的加-
	MOV -> 数据移动
	R 	-> 寄存器
	Mem	-> 存储单元
	
```

![]()<img src="https://raw.githubusercontent.com/wyf195075595/images/main/blog/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4.png" alt="汇编指令" style="zoom:75%;" />

```js
汇编语言是面向硬件的，感觉对编程不够好使。

▪高级语言：独立于机器的硬件系统、面向过程或对象的语言，它较接近自然语言或数学语言

eg: 用 python语言表示上边操作
	Z = X + Y

▪一条高级语言语句可对应多条机器指令
	eg: X = X + 2 + 3 + 4
		☛ x = x + 2
		☛ x = x + 3
		☛ x = x + 4
		
"计算机只能执行机器语言程序"
所以其他语言想要运行，就需要先 "编译" 成机器指令序列

▪高级语言编写的程序称之为 "源程序"
▪编译之后得到的0/1代码则被称为"可执行程序"
```

|          | 效率 | 可读性 | 表达能力 |
| -------- | ---- | ------ | -------- |
| 机器语言 | 高   | 差     | 弱       |
| 汇编语言 | 一般 | 一般   | 一般     |
| 高级语言 | 低   | 好     | 强       |

## TOY计算机

> 实现TOY计算机

![](https://raw.githubusercontent.com/wyf195075595/images/main/blog/TOY%E6%8C%87%E4%BB%A4%E9%9B%86.png)

```js
◆寄存器：CPU中用于存放数据和状态的临时存储单元
	▪Rx，Ry: CPU中某个通用的寄存器编号（取值整数）
	-分类
		1、通用寄存器
			*用来保存操作数和运算结果
			*用户可使用
		2、专用寄存器（只对CPU开放）
			*用来保存指令执行过程中的状态信息
			*用户不可见
	
◆主存单元：主存被分为一个个的单元格，数据按字节顺序放在在这些单元格中
	▪mem: 主存中的某个存储单元（取值为整数）
	
	-主存地址：主存单元编号
		1、编号从0开始，依次加1
		2、地址的长度决定系统支持的最大主存容量
            ◆4 位地址： 2^4 = 16B
            ◆32 位地址： 2^32 = 4GB
            
     -主存访问
		√ 通过主存地址对主存单元数据进行读写
         √ 至少存取一个字节
                
                
    32位操作系统支持的内存是2的32次方,也就是4GB内存。而64位操作系统理论上的寻址空间为2的64次方bit,转化单位为2147483648GB。 目前,电脑最大支持内存的瓶颈主要取决于主板,主板最大支持的内存最大量决定了最大内存条的容量。

```

<img src="https://raw.githubusercontent.com/wyf195075595/images/main/blog/%E4%B8%BB%E5%AD%98%E7%BB%93%E6%9E%84.png" style="zoom:75%;" />

## 模拟主存

```js
◉用那种数据类型来模拟主存
	-数组
	-1000个元素 <--> 100个主存单元
	-元素编号 <--> 主存地址
	-元素类型： 字符串
	
	men = new Array(1000).fill('')
	men用于模拟主存，共1000个主存单元
```

## 模拟程序加载

```js
const fs = require('fs').promise
// file 用于保存文件的路径
function loadProgram(file) {
    return fs.readFile(file, {encode:'utf-8'})
}

// 指令文件内容
地址  指令
000 move3 1 0

mem[地址] = 指令


程序指令和数据共同存放在 储存器中
自动化 和 序列化 地 执行程序指令

执行程序
	1、定义变量
	mem = new Array(1000).fill('');// 主存， 1000个单元
	reg = new Array(10).fill(0);// 通用寄存器， 10个
	pReg = 0;// 程序计数器
	iReg = '';// 指令寄存器

	2、函数
        loadProgram();// 读取指令文件并保存指令至主存
        // 完整执行一条指令
    	function cycle() {
            iReg = mem[pReg];// 从主存取指令
            pReg++;// 计数器自增
            
            let [opCode, op1, op2] = iReg.split(' ');
            if(op1) op1=parseInt(op1);
            if(op2) op2=parseInt(op2);
            
            switch(opCode) {
                // 停止
                case 'halt':
                    return false
                break;
                // 数据移动 内存-》寄存器
                case 'mov1':
                    reg[op1] = mem[op2]
                break;
                // 加法
                case 'add':
                	reg[op1] = reg[op1] + reg[op2]
                break;
                // 跳转
                case 'jmp':
                    pReg = op1
                break;
           	}
            return true
        }; 
        // 执行 fileName 文件中地 TOY程序
		function run (fileName) {
            loadProgram(fileName);
            hasNextInstruc = true;
            while hasNextInstruc {
                hasNextInstruc = cycle()
            }
        }
```

## CPU组成结构

```js
CPU
	-ALU(算术逻辑单元)
        ▪算术运算 +-*/
        ▪逻辑运算 与、或、非、异或等
	-寄存器
        ▪数量有限，稀缺资源
        ▪通用寄存器 （操作数，结果）
        ▪专用寄存器 （计算机当前状态，CPU专用）
	-控制单元
        ▪分析指令
        ▪传送指令及操作数
        ▪产生时序逻辑，控制和协调整个CPU工作
        
        ▪PC（程序计数器） 下一条指令地址
        ▪IR（指令寄存器） 当前指令
        ▪ID（指令译码器） 根据IR内容，决定进行何种操作
        ▪OC（操作控制器） 操控各种操作：取指令，取数，控制ALU
        
    -CPU内部总线
        ▪数据和指令在CPU中地传送通道
        	-数据总线（DB）
        	-地址总线（AB）
        	-控制总线（CB）
		
 取指令 -》 译码 -》 执行 -》 写结果
 
 ▪循环执行指令地过程
 	-在CPU地控制下，精确的，一步一步地完成
 ▪一条指令执行地时间称为指令周期，每一步称为一个节拍
 ▪时钟周期
 	-CPU工作地最小时间单位
	-一个节拍可能花费多个时钟周期
		例如： 取指令花费三个时钟周期
 ▪始终频率（主频） = 1 / 时钟周期
	如：3.1GHz （31亿次/秒）
```

![]()<img src="https://raw.githubusercontent.com/wyf195075595/images/main/blog/CPU.png" alt="CPU" style="zoom:75%;" />

