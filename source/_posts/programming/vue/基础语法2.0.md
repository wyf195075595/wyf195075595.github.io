---
title:  vue 2.0 基础知识
date: 2022-06-17 08:23:10
tags: 基础知识
categories: vue
---
![这里写图片描述](http://cn.vuejs.org/images/mvvm.png?_=5619070)

## 指令

v-once：执行一次性地插值，当数据改变时，插值处的内容不会更新

v-html：双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 v-html

v-text:更新元素的 `textContent`。如果要更新部分的 `textContent`，需要使用 `{{ Mustache }}` 插值

v-pre:跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译

v-cloak:这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 `[v-cloak] { display: none }` 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕

```css
[v-cloak] {
  display: none;
}

```



​	计算属性是一个属性不需要函数调用方式进行使用，简写的默认为get方法，一般计算属性没有set方法，只读属性。

计算属性会进行缓存，多次使用计算属性之后调用一次



<!--more-->

## 事件修饰符

.stop：停止冒泡     

.prevent：阻止默认事件

.capture：添加事件监听器时使用事件捕获模式，内部元素触发的事件先在此处理，然后才交由内部元素进行处理

.self 只当在 event.target 是当前元素自身时触发处理函数

.once：点击事件将只会触发一次

## 按键修饰符

.enter   .tab    .`delete` (捕获“删除”和“退格”键

.esc .space .up   .down .left .right

`config.keyCodes` 对象自定义按键修饰符别名 Vue.config.keyCodes.f1 = 112

系统修饰键

.ctrl .alt .shift .meta(Mac下是 Command键，Windows 下是窗口键)

<!-- Alt + C --> <input v-on:keyup.alt.67="clear">

## 数据双向绑定 v-model

`v-model` 会忽略所有表单元素的 `value`、`checked`、`selected` attribute 的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 `data` 选项中声明初始值。

- text 和 textarea 元素使用 `value` property 和 `input` 事件；
- checkbox 和 radio 使用 `checked` property 和 `change` 事件；
- select 字段将 `value` 作为 prop 并将 `change` 作为事件

修饰符：

.lazy 在默认情况下，`v-model` 在每次 `input` 事件触发后将输入框的值与数据进行同步,添加 `lazy` 修饰符，从而转为在 `change` 事件_之后_进行同步

数据在失去焦点或者回车才会更新

.number 将用户的输入值转为数值类型 无法被 `parseFloat()` 解析，则会返回原始的值

.trim  自动过滤用户输入的首尾空白字符

## 组件

组件data为什么是个函数？

 函数每次执行后返回一个新的对象，组件之间的数据不会相互影响

is 属性挂在元素，可以规避HTML的限制。如 table标签只允许是 tr,td，th等表格元素，所以在table内直接使用组件是无效的。

​		<table> <tbody is="my-component"></tbody> </table>

父传子：props

组件里什么接受那些属性，props可以设置类型限制，提供一些默认值（react则还需使用prop-types库）

数据单向传递，子组件不能直接修改父组件数据

子传父：自定义事件

 $emit，$on

 不要v-model直接绑定props的属性到子组件



父子组件访问方式

1、使用$children 或者$refs reference引用

父访问子（子链）

ref 用来为子组件设置索引 ， 可通过 this.$refs.comA.msg 来访问指定的实例 

2、使用$parent  $root

子访问父亲（父链）

非父子组件通信 

​	1.0、$dispatch,$broadcast 前者用于向上级（只要是它的父级【一级或多级】）派发事件，后者 是由上级向下级广播事件，一旦发出事件，任何组件都能接收到，而且会在第一次接收到后停止冒泡，除非返回true

```js
$dispatch ：由下往上广播
$broadcast：由上往下广播

//父级
events : { 
    'on-message'： functi (msg) { 
        this.message = msg ; 
    }
}

//子级【一级或多级】
methods:{
    handleDispatch:function(){
        this.$dispatch('on-message','来自子级')
    }
}
```

​	2.0、bus（中央事件总线，相当于一个中介，帮助组件间传递消息）

```js
var bus= new Vue ();

//父级
mounted(){
    //定义事件
    var _this = this;
    bus.$on('on-message', function(msg){
        console.log('非父子：',msg);
        _this.message = msg;
    })
}

//子级【一级或多级】
methods:{
    handleMsg:function(){
        bus.$emit('on-message','来自孙子的问候')
    }
},
```

## slot插槽的使用

组件内部需要在某个位置显示外部传入的具体内容，使用slot标签进行占位，同时slot内部可以设置默认内容（直接在内部定义子元素，也可以是组件），外部传入内容会替换默认内容

具名插槽：slot标签上添加name属性，设置插槽具体名称，使用的时候标签添加slot属性并设置对应的名称

编译作用域：父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的



作用域插槽

1、父组件替换插槽的标签，内容由子组件提供

```js
<span>
  <slot v-bind:user="user">
    {{ user.lastName }}
  </slot>
</span>

<current-user>
  <template v-slot:default="slotProps">     //老版本使用slot-scope ,还可以用 #default="slotProps"
    {{ slotProps.user.firstName }}
  </template>
</current-user>

1、单个slot
<div id = "app">
    <child-component>
    	<p>分发的内容</p>
    	<p>更多分发的内容</p>
    </child-component>
</div>

<script>
	Vue.component('child-component',{
        template:`
            <div>
				<solt>
					<p>如果父组件没有插入内容，我将默认出现</p>
				</solt>
            </div>
		`	
		
    })

	var app = new Vue({
        el:'#app',
        data:{
            
        }
    })
</script>

2、具名slot
<div id = "app">
    <child-component>
    	<h2 solt="header">标题</h2>
    	<p>正文内容</p>
    	<p>更多正文内容</p>
    	<div slot="footer">底部信息</div>
    </child-component>
</div>

<script>
	Vue.component('child-component',{
        template:`
            <div>
				<div class="header">
					<solt name = "header"></slot>
				</div>
				<div class="main">
					<slot></slot>
				</div>
				<div class="footer">
					<solt name = "footer"></slot>
				</div>
            </div>
		`	
		
    })
    var app = new Vue({
        el:'#app',
        data:{

        }
    })
</script>
3、作用域插槽
	可以让子组件的内容在父级渲染
<div id = "app">
    <my-list :books="books">
    	//作用域插槽也可以是具名插槽
        <template slot="book" scope="props">
            // 下面其实也可以使用 book.bookName
            <li>{{ props.bookName }}</li>
        </template>
    </my-list>
</div>

<script>
	Vue.component('my-list',{
        props:{
            books:{
                type:Array,
                default:function(){
                    return [];
                }
            }
        }
        template:`
            <ul>
				//此处暴露的 book-name 在作用域插槽上可以使用
				<slot name="book" v-for="book in books" :book-name ="book.name">
				
				</slot>
            </ul>
		`	
		
    })
    var app = new Vue({
        el:'#app',
        data:{
			books:[
                {name:'Vue.js实战'},
                {name:'js语言精粹'},
                {name:'js高阶程序设计'},
            ]
        }
    })
</script>
    
4、获取插槽中的内容
	
    this.$slot.default 获取当前实例上所有插槽 （不包括作用域插槽）
    this.$slot.header  获取指定 name 的插槽中的内容
```

## 组件的高级用法

```js
1、递归组件
	场景：级联选择器，树形控件
    
    简单栗子：
    <script>
        Vue.component('my-list',{
            name:'my-list',//要设置name
            props:{
                count:{
                    type:Number,
                    default:1
                }
            }
            template:`
                <div>
                    <my-list :count="count + 1" v-if="count < 3"></my-list>
                </div>
            `
        })
    </script>
2、内联模板
	
	<div id="app">
        <child-component inline-template>
            <div>
            	<h2>在父组件中定义子组件的模板</h2>
                <p>{{ message }}</p>
                <p>{{ msg }}</p>
        	</div>
		</child-component>
     </div>
	<script>
        Vue.component('child-component',{
            data:function (){
                return {
                    msg: '在子组件声明的数据'
                }
            }        
        })
        var app = new Vue({
            el:'#app',
            data:{
                message: '在父组件声明的数据'
            }
        })
    </script>
        
    渲染后结果为：
    
	<div id="app">
        <div>
            <h2>在父组件中定义子组件的模板</h2>
            <p>在父组件声明的数据</p>
            <p>在子组件声明的数据</p>
        </div>
     </div>

	这个效果与 作用域插槽有些类似。子组件的模板可以直接访问父组件数据。但是父子组件重名数据，优先使用子组件
    
3、动态组件
	Vue.js提供了一个特殊的元素 <component> 用来动态地挂载不同的组件，使用is特性来选择要挂载的组件
		实现动态切换要显示的组件
	<div id="app">
        <component :is = "currentView"></component>
        <button @click="handleChangeView('A')">切换到A</button>
	</div>
	<script>
        var app = new Vue({
            el:'#app',
            components:{
                comA:{template:`<div>组件A</div>`},
                comB:{template:`<div>组件B</div>`},
                comC:{template:`<div>组件C</div>`},
            },
            data:{
                currentView:'comA'
            },
            methods:{
                handleChangeView(part){
                    this.currentView = 'com'+part;
                }
            }
        })
    </script>
	
4、异步组件

	因为一开始就加载全部组件是没必要的开销，Vue.js 允许将组件定义为一个工厂函数，动态解析组件。只在组件需要渲染时触发工厂函数，并缓存结果。
    工厂函数的reject(reason)表提示加载失败。下面setTimeout演示异步，也可以是Ajax等
	<div id="app">
        <child-component></child-component>
    </div>
	<script>
        Vue.component('child-component',function(resolve, reject){
        	window.setTimeout(function(){
                resolve({
                    template:'<div>我是异步函数</div>'
                })
            },2000);
        })
        var app = new Vue({
            el:'#app'
        })
     </script>
```

## 其他

```js
$nextTick
	$nextTick 就是用来知道什么时候DOM更新完成
	场景：有一个div，默认用 v-if 将它隐藏，点击一个按钮后改变 v-if的值，让它显示出来。同时拿到这个div的文本内容。
	
	
	<div id="app">
        <div id="div" v-if="showDiv">这是一段文本</div>
        <button @click="getText">获取div内容</button>
     </div>
	<script>
        var app = new Vue({
            el:'#app',
            data:{
                showDiv:false,
                count:0
            },
            methods:{
                getText:function(){
                    this.showDiv = true;
                    //Vue在观察到数据变化时，，并不是直接更新DOM，而是开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。在缓冲时去除重复数据，避免不必要的计算和DOM操作。然后在下一个事件循环tick中，Vue刷新队列并执行实际工作。例如：用for循环 100 改变 data 中数据 count，vue只会执行最后一次更新的结果
                    1、错误
                    var text = document.getElementById('div').innerHTML;
                    console.log(text);
                    2、正确
                    this.$nextTick(function(){
                        var text = document.getElementById('div').innerHTML;
                        console.log(text);
                    })
                }
            }
        })
     </script>



X-Templates
	组件模板 : 用来解决 组件template 内容冗长问题
    <div id="app">
        <my-component></my-component>
		<script type="text/x-template" id="my-component">
            <div>这是组件内容</div>
         </scipt>
     </div>
	<script>
         Vue.component('my-component',{
            template:'#my-component'
        })
	     var app = new Vue({
             el:'#app'
         })
     </script>

手动挂载实例
	在一些特殊情况下，我们需要动态的去创建Vue实例，Vue提供了Vue.extend 和 $mount 两个方法来手动挂载一个实例。
    Vue.extend是基础Vue构造器，创建一个“子类”,参数是一个包含组件选项的对象。如果Vue实例在实例化时没有接收到el选项，它就处于“未挂载”状态，没有关联的DOM元素。可以使用 $mount() 手动的挂载一个未挂载的实例。方法返回实例本身
    
    <div id="mount-div">
        
    </div>
	<script>
        var MyComponent = Vue.extend({
            template:`<div>Hellow:{{name}}</div>`,
            data:function(){
                return {
                    name:'Aresn'
                }
            }
        })
        方式1
        	new MyComponent().$mount('#mount-div');
        方式2
        	new MyComponent({el:'#mount-div'})
        方式3
        	var component = new MyComponent().$mount();//挂载在文档之外
            document.getElementById('mount-div').appendChild(component.$el);
		
    </script>
```

## 自定义指令

```js
内置指令
	v-if, v-for, v-show...
 
自定义指令
	写法与注册组件基本类似，只是方法名 有 component 改为 directive

1、全局注册

Vue.directive('focus',{
    //指令选项，由钩子函数组成
    bind：只调用一次。第一次绑定元素时调用
    insert：被绑元素插入父节点时调用（父节点存在即可调用）
    update：被绑元素所在模板更新时调用
    componentUpdated：被绑元素所在模板完成一次更新周期调用
    unbind：只调用一次，指令解绑时调用
    
    //上面钩子函数的参数
    el：指令所绑定的元素，可以直接操作DOM
    binding：一个对象，包含以下属性
    	-name	指令名，不包括前缀 v-
    	-value  指令的绑定值，如 v-focus="1+1",value就是2
    	-oldVaalue	指令绑定的前一个值，仅在 update,componentUpdated钩子中可用，无论值是否改变都可用
    	-expression	绑定值的字符串形式，如 v-focus="1+1", expression的值就是 "1+1"
    	-arg	传给指令的参数。如 v-my-directive:foo, arg的值就是 foo
    	-modifiers	一个包含修饰符的对象。如 v-focus.foo.bar, 修饰符对象就是{foo:true,bar:true}
    vnode：Vue编译生成的虚拟节点
    oldVnode：上一个虚拟节点仅在 update 和 componentUpdated钩子中可用
})

2、局部注册
var app = new Vue({
    el:'#app',
    directives:{
        focus:{
            //指令选项
        }
    }
})
```

## Virtual Dom

```js
vNode对象 Vue.js源码定义：
export interface VNode { 
    tag?: string; //标签名
    data?: VNodeData; //数据对象
    children?: VNode[);//子节点，也是vNode类型 
    text?: string; //文本，一般文本节点，注释节点有该属性
    elm?: Node; //真实DOM节点
    ns?: string; //命名空间
    context?: Vue; //上下文（作用域）
    key?: string I number; //key属性，作为节点标识，有利于patch优化
    componentOptions?: VNodeComponentOptions; //创建组件实例会用到的选项信息
    componentInstance?: Vue; //组件实例
    parent?: VNode ; //组件占位节点
    raw?: boolean; //原始 html
    isStatic?: boolean; //静态节点标识
    isRootinsert: boolean; //是否作为根节点插入
    isComment: boolean;//是否作为注释节点
    
    child://当前节点对应组件实例
    isCloned:boolean;//是否克隆节点
    isOnce:boolean;//是否有 v-once指令
}


```

## Render函数

```js
要在合适的场景使用Render函数，否则只会怎加负担
eg:
    <div id = "app">
        <anchor :level = "2" title = "特性">特性</anchor>
    </div>
    <script>
        Vue.component('anchor',{
            props:{
                level:{
                    type:Number,
                    required:true,
                },
                title:{
                    type:String,
                    default:''
                }
            },
            render: function(createElement){
                return createElement(
                    'h' + this.level,
                    [
                        createElement(
                            'a',
                            {
                                domProps:{
                                    href:'#'+this.title
                                }
                            },
                            this.$slots.default
                        )
                    ]
                )
            }
        })

        var app = new Vue({
            el:'#app'
        })
    </script>
        
 createElement 用法
 
 createElement(
     //必选 String | Object | function
     //可以是HTML标签，也可以是一个组件或函数（必须return 上述一个）
 	'div',
     //可选 {Object}，数据对象：在template中使用
     {
         //和 :class 一样的API
         'class':{
             foo:true
         },
         //和 :style 一样的API
         'style':{
         	color:'red'
         },
         //正常的 HTML 属性
         'attrs':{
             id:'foo'
         },
         //组件 props
         props:{
             myProp:'bar'
         },
         //DOM属性
         domProps:{
             innerHTML:'xxx'
         },
         //自定义事件监听器【不支持如 @keyup.enter的修饰器，需手动匹配keyCode】
         on:{
             nclick:this.nativeClickHandler
         },
         //仅对组件监听原生事件【不可像 vm.$emit触发自定义事件】
         nativeOn:{
             click:this.nativeHandler
         },
         //自定义指令
         directives:[
             {
                 name:'focus',
                 value:'1',
                 arg:'foo',
                 modifiers:{
                     bar:true
                 }
             }
         ],
         //作用域slot {name:props=>VNode|Array<VNode>}
         scopeSlots:{
             default:props=>h('span',props.text)
         },
         //具名slot
         slot:'name-of-slot',
         //其他特殊层属性
         key:'myKey',
         ref:'myRef'
     },
     //可选，子节点(VNode) String|Array
     []
 )

render函数的约束
	所有组件树种，如果是组件或含有组件的slot， 那么VNode必须唯一。
    
    var Child = { 
        render: function(createElement) { 
            return createElement ( ’ p ’,’text ’ ) ;
        }
    };
	
    Vue.component('ele',{
		render: (createElement) { 
            //ChildNode 不是唯一，只会渲染出一个
            var ChildNode = createElement(Child); 
            return createElement ( 'div', [ ChildNode , ChildNode ]);
            //正确写法
            return createElement('div',
            	Array.apply(null,{length:2}).map(function(){
                	return createElement(Child)
                })                    
            )

        }        
    })

render函数中不能使用指令等模板语法，需要用原生js代替


函数化组件
    Vue. 提供了 functional 的布尔值选项，设置为 true 可以使组件无状态和无实例，也就是 没有 data this 上下哀。这样用 render 函数返回虚拟节点可以更容易渲染，因为函数化组件只是一个函数，渲染开销小很多


```

## 插件

```js
MyPlugin.install = function (Vue, options ){
    //全局注册组件 component-name
    Vue.component('component-name',{
        
    })
    //添加实例方法 $Notice
    Vue.prototype.$Notice = function(){
        
    }
    //添加全局方法或属性
    Vue.globalMethod = function(){
        
    }
    //添加全局混合
    Vue.mixin({
        mounted:function(){
            
        }
    })
}


在（全局js） main.js
//使用插件
Vue.use(MyPlugin,{
    //可传参
})




//事件总线的插件
vue-bus.js

const install = function(Vue){
    const Bus = new Vue({
        methods:{
            emit(event, ...args){
                this.$emit(event, ...args);
            }
        },
        on(event, callback){
            this.$on(event, callback);
        },
        off(event, callback){
            this.$off(event, callback)
        }
    })
    Vue.prototype.$bus = Bus;
};

export default install;
```







runtime-only ->代码里面不可以有任何template

runtime-compiler->代码含有template，compiler可以编译template



el和template的关系：当el和template同时出现的时候，template中的代码会替代el挂载的DOM元素



![image-20210428143431762](C:\Users\vvrec\AppData\Roaming\Typora\typora-user-images\image-20210428143431762.png)

1、runtime-compiler 和 runtime-only 的运行原理（运行过程）？

runtime-compiler：template->ast(abstract syntax tree)->render->virtual dom->UI

runtime-only：性能更高、代码量更少：render->virtual dom->UI

2、npm install vue-loader vue-template-compiler --save-dev中的vue-template-compiler的作用是什么？

vue-template-compiler将vue中的template转换成render

3、Runtime-Compiler和Runtime-only的选择使用情况？

如果在之后的开发中，你依然使用template，就需要选择Runtime-Compiler

如果你之后的开发中，使用的是.vue文件夹开发，那么可以选择Runtime-only

![image-20210428143824891](C:\Users\vvrec\AppData\Roaming\Typora\typora-user-images\image-20210428143824891.png)

![image-20210428143852946](C:\Users\vvrec\AppData\Roaming\Typora\typora-user-images\image-20210428143852946.png)



vue-cli 3创建项目

vue create 项目名称



vue-router

使用：导入vue和vue-router

1、通过vue.use（插件）安装插件

2、创建VueRouter对象

3、配置routes映射关系，导处router

4、main.js把router对象挂载在vue实例上



路由的默认值和修改history模式：

使用redirect重定向，配置创建VueRouter对象时候传入第二个参数mode为history或者为hash

```js
 <router-link to="/home">Go to home</router-link>
      <router-link to="/about">Go to about</router-link>
      <!-- 路由出口 -->
      <!-- 路由匹配到的组件将渲染在这里 -->
      <router-view></router-view>
      

tag：添加tag属性渲染为成其他的标签，默认渲染为a标签
设置replace模式：router-link上直接加上replace
active-class：默认名称router-link-active,例如使用active，则添加属性active-class="active"---->也可以在路由文件里面配置linkActiveClass:'active'


histroy 模式

const RouterConfig = {
    mode:'histroy',//默认hash模式
    routes:Routers
}

const router = new VueRouter(RouterConfig);

new Vue({
    el:'#app',
    router,
    render:h=>{
        return h(App)
    }
});

//[注意]在生产环境时服务器端必须进行配置，将所有路由都指向同一个 html，或设置404页面为该页面。否则刷新会出现404
webpack-dev-server也需要配置支持History
在package.json中修改启动命令
"script":{
    "div":"webpack-dev-server --open --history-api-fallback --config webpack.config.js"
}
//--history-api-fallback, 所有路由都会指向 index.html
```

编程式导航

**在 Vue 实例内部，你可以通过 `$router` 访问路由实例。因此你可以调用 `this.$router.push`**

router.push、 router.replace 和 router.go 跟 window.history.pushState、 window.history.replaceState 和 window.history.go好像， 实际上它们确实是效仿 window.history API 的

```js
// 字符串
router.push('home')

// 对象
router.push({ path: 'home' })

// 命名的路由
router.push({ name: 'user', params: { userId: '123' }})

// 带查询参数，变成 /register?plan=private
router.push({ path: 'register', query: { plan: 'private' }})

//前进后退 负数为后退，整数为前进
router.go(-1);
```

**如果提供了 `path`，`params` 会被忽略**

router配置对象

```js
//未解耦
const User = {
  template: '<div>User {{ $route.params.id }}</div>'
}
//解耦
const User = {
  props: ['id'],
  template: '<div>User {{ id }}</div>'
}
const Routers = [
    {
        path:'/index',
        //别名 当用户访问 /first 时，匹配/index
        alias:'first'
        //元信息 通过 to.matched / $route.matched 访问
        meta:{
            title:'首页'
        },
    	//重定向
    	//可以是一个方法(接收目标路径) to=>{}，(命名路由) {name:'foo'}，
    	redirect:'/foo',
        component:(resolve)=> require(['./views/index.vue'], resolve)
    },
    {
        path:'/b',
        // 在/b路劲下，有同级路由 Sidebar
        components: { default: User, sidebar: Sidebar },
    }，
    // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：
    {
      path: '/user/:id',
      components: { default: User, sidebar: Sidebar },
      //如果 props 被设置为 true，route.params 将会被设置为组件属性
      props: { default: true, sidebar: false },
      //URL /search?q=vue 会将 {query: 'vue'} 作为属性传递给 SearchUser 组件。
      props: route => ({ query: route.query.q })
    }
]

const router = new VueRouter(RouterConfig);

导航钩子函数
// to 即将进入的目标的路由对象
// from 当前导航即将要离开的路由钩子
// next 调用该方法，才能进入下一个钩子
实现每次进入页面修该页面标题
router.beforeEach((to, from, next)=>{
	window.document.title = to.meta.title;
    next();
})
实现每次跳转页面回到页面顶部
router.afterEach((to, from, next)=>{
    window.scrollTo(0,0);
})
```

命名视图

有时候，通过一个名称来标识一个路由显得更方便一些，特别是在链接一个路由，或者是执行一些跳转的时候。你可以在创建 Router 实例的时候，在 `routes` 配置中给某个路由设置名称。

```js
//动态路由匹配   path: '/user/:userId',
const router = new VueRouter({
  routes: [
    {
      path: '/user/:userId',
      name: 'user',
      component: User
    }
  ]
})
```

要链接到一个命名路由，可以给 `router-link` 的 `to` 属性传一个对象

```
<router-link :to="{ name: 'user', params: { userId: 123 }}">User</router-link>

router.push({ name: 'user', params: { userId: 123 } })

路由组件内部可以通过$route.params或者$route.query     当前活跃的路由映射对象
```



其实写router-link或者编程式导航是否传递数据跟路由匹配应该区分开来，路径匹配是路由路径匹配，也就是不用动态路由也可以进行传参数，动态路由只是一种匹配模式



嵌套路由

1、创建对应子组件，在路由映射配置对应子路由

2、在组建内部使用<router-view></router-view>  ，在哪里显示就加在哪



传递参两种方式params和query

params类型：

1、配置路由格式：/router/:id

传递方式：path后面跟上对应的值

传递后路径类似于:/router/123,router/abc

2、动态路由匹配   

配置路由格式：/router/:id

const router = new VueRouter({
  routes: [
    {
      path: '/user/:userId',
      name: 'user',
      component: User
    }
  ]
})

传递方式：<router-link :to="{ name: 'user', params: { userId: 123 }}">User</router-link>

如果提供了 `path`，`params` 被忽略

传递后路径类似于:/router/123,router/abc

query类型：

配置路由格式：/router  普通配置格式

传递方式：使用query的key作为传递      :to={ path: 'register', query: { plan: 'private' }}

传递后路径：  

/register?plan=private

## 完整的导航解析流程

```js

导航被触发。
在失活的组件里调用 beforeRouteLeave 守卫。
调用全局的 beforeEach 守卫。
在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。
在路由配置里调用 beforeEnter。
解析异步路由组件。
在被激活的组件里调用 beforeRouteEnter。
调用全局的 beforeResolve 守卫 (2.5+)。
导航被确认。
调用全局的 afterEach 钩子。
触发 DOM 更新。
调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。

```

路由元数据：定义路由的时候可以配置 `meta` 字段

`routes` 配置中的每个路由对象为 **路由记录**。路由记录可以是嵌套的，因此，当一个路由匹配成功后，他可能匹配多个路由记录

例如，根据上面的路由配置，`/foo/bar` 这个 URL 将会匹配父路由记录以及子路由记录。

一个路由匹配到的所有路由记录会暴露为 `$route` 对象 (还有在导航守卫中的路由对象) 的 `$route.matched` 数组。因此，我们需要遍历 `$route.matched` 来检查路由记录中的 `meta` 字段。

```js
router.beforeEach((to, from, next) => {
  if (to.matched.some(record => record.meta.requiresAuth)) {
    // this route requires auth, check if logged in
    // if not, redirect to login page.
    if (!auth.loggedIn()) {
      next({
        path: '/login',
        query: { redirect: to.fullPath }
      })
    } else {
      next()
    }
  } else {
    next() // 确保一定要调用 next()
  }
})
```

## 过渡

```js
//可以动态设置 动画效果
<transition :name="transitionName">
  <router-view></router-view>
</transition>
```

## Vuex

由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在[计算属性 (opens new window)](https://cn.vuejs.org/guide/computed.html)中返回某个状态：

```js
// 创建一个 Counter 组件
const Counter = {
  template: `<div>{{ count }}</div>`,
  computed: {
    count () {
      return store.state.count
    }
  }
}
```

每当 `store.state.count` 变化的时候, 都会重新求取计算属性，并且触发更新相关联的 DOM

![vuex](https://vuex.vuejs.org/vuex.png)



1. 应用层级的状态应该集中到单个 store 对象中。
2. 提交 **mutation** 是更改状态的唯一方法，并且这个过程是同步的。
3. 异步逻辑都应该封装到 **action** 里面。

只要你遵守以上规则，如何组织代码随你便。如果你的 store 文件太大，只需将 action、mutation 和 getter 分割到单独的文件。

对于大型应用，我们会希望把 Vuex 相关代码分割到模块中。下面是项目结构示例：

```
├── index.html
├── main.js
├── api
│   └── ... # 抽取出API请求
├── components
│   ├── App.vue
│   └── ...
└── store
    ├── index.js          # 我们组装模块并导出 store 的地方
    ├── actions.js        # 根级别的 action
    ├── mutations.js      # 根级别的 mutation
    └── modules
        ├── cart.js       # 购物车模块
        └── products.js   # 产品模块
```

由来？

组件之间通信成了必不可少的开发需求,完成非关系型组件数据共享

父传子->props

子传父亲->$emit

兄弟节点->eventBus->公共$emit

$on和$emit的事件必须是在一个公共的实例上才能触发

新建eventBus.js

```
import Vue from 'vue'

export default new Vue()
```

组件1监听

```
import eventBus from './eventBus'
//...
created () {
  eventBus.$on('my-event', args => {
  //...
  }) 
}
```

组件2触发

```
import eventBus from './eventBus'
//...
watch: {
  list(newValue, oldValue) {
    eventBus.$emit('my-event', newValue)
  }
}
```



Vue.set() --->响应式   dep->watch观察者模式

delete、[]、不是响应式

Vue.delete()--->响应式  :不是响应式设置为响应式

既然 Vuex 的 store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新。这也意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项：

1. 最好提前在你的 store 中初始化好所有所需属性。
2. 当需要在对象上添加新属性时，你应该

- 使用 `Vue.set(obj, 'newProp', 123)`[ this.$set(this.obj, 'newprop', 123) ]或者 

- 以新对象替换老对象。例如，利用[对象展开运算符 (opens new window)](https://github.com/tc39/proposal-object-rest-spread)我们可以这样写：

	```js
	state.obj = { ...state.obj, newProp: 123 }
	```
	
	## State

```js
Vuex 通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中（需调用 Vue.use(Vuex)）：

const app = new Vue({
  el: '#app',
  // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件
  store,
  components: { Counter },
  template: `
    <div class="app">
      <counter></counter>
    </div>
  `
})

通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到。



mapState 
	辅助函数  获取多个状态时，减少代码重复和冗余

// 在单独构建的版本中辅助函数为 Vuex.mapState
import { mapState } from 'vuex'

export default {
  // ...
  computed: mapState({
    // 箭头函数可使代码更简练
    count: state => state.count,

    // 传字符串参数 'count' 等同于 `state => state.count`
    countAlias: 'count',

    // 为了能够使用 `this` 获取局部状态，必须使用常规函数
    countPlusLocalState (state) {
      return state.count + this.localCount
    }
  })
}


当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。

computed: mapState([
  // 映射 this.count 为 store.state.count
  'count'
])


mapState 函数返回的是一个对象。我们如何将它与局部计算属性混合使用呢？

computed: {
  localComputed () { /* ... */ },
  // 使用对象展开运算符将此对象混入到外部对象中
  ...mapState({
    // ...
  })
}
```

## Getters

```js
有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数：

//其他地方用到的话，就不方便了
computed: {
  doneTodosCount () {
    return this.$store.state.todos.filter(todo => todo.done).length
  }
}

const store = new Vuex.Store({
  state: {
    todos: [
      { id: 1, text: '...', done: true },
      { id: 2, text: '...', done: false }
    ]
  },
  //getters就解决这个 问题
  getters: {
    doneTodos: state => {
      return state.todos.filter(todo => todo.done)
    },
    doneTodosCount: (state, getters) => {
      return getters.doneTodos.length
    },
    //实现外部传参
    getTodoById: (state) => (id) => {
        return state.todos.find(todo => todo.id === id)
    },
    anotherGetter:(state, getters)=>{
      //内部访问
      return store.getters.doneTodosCount + 10
        
    }
  }
})


//外部访问
computed: {
  doneTodosCount () {
    return this.$store.getters.doneTodosCount
  }
},
methods:{
    todo(){
        store.getters.getTodoById(2) // -> { id: 2, text: '...', done: false }
    }
}


mapGetters 辅助函数
	mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：

import { mapGetters } from 'vuex'

export default {
  // ...
  computed: {
  // 使用对象展开运算符将 getter 混入 computed 对象中
    ...mapGetters([
      'doneTodosCount',
      'anotherGetter',
      // ...
    ])
      
      
  如果你想将一个 getter 属性另取一个名字，使用对象形式：
    ...mapGetters({
      // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`
      doneCount: 'doneTodosCount'
    })
      
  }
}
```

## Mutation

```js
更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。

const store = new Vuex.Store({
  state: {
    count: 1
  },
  mutations: {
    //提交载荷
    increment (state, n) {
        state.count += n
      }
  }
})
//不能直接调用 increment 方法
store.commit({
  type: 'increment',
  amount: 10
})

使用常量替代 Mutation 事件类型，多人协作时比较方便。
一条重要的原则就是要记住 mutation 必须是同步函数。
	-不利于devtools追踪状态，实质上任何在回调函数中进行的状态的改变都是不可追踪的。
```

## Action

```js
Action 类似于 mutation，不同在于：
    Action 提交的是 mutation，而不是直接变更状态。
    Action 可以包含任意异步操作。

const store = new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
    increment (state) {
      state.count++
    }
  },
  actions: {
    increment (context) {
      context.commit('increment')
    }
    //简化写法
   	increment ({ commit }) {
       commit('increment')
    }
  }
})

分发 Action

Action 通过 store.dispatch 方法触发：
//普通分发
store.dispatch('increment')

// 以载荷形式分发
store.dispatch('incrementAsync', {
  amount: 10
})

// 以对象形式分发
store.dispatch({
  type: 'incrementAsync',
  amount: 10
})


mapActions

import { mapActions } from 'vuex'

export default {
  // ...
  methods: {
    ...mapActions([
      'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`

      // `mapActions` 也支持载荷：
      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`
    ]),
    ...mapActions({
      add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`
    })
  }
}


组合 Action


//通过这种方式，代替回调函数方式
store.dispatch('actionA').then(() => {
  // ...
})

//async-await
// 假设 getData() 和 getOtherData() 返回的是 Promise

actions: {
  async actionA ({ commit }) {
    commit('gotData', await getData())
  },
  async actionB ({ dispatch, commit }) {
    await dispatch('actionA') // 等待 actionA 完成
    commit('gotOtherData', await getOtherData())
  }
}

```

## modules

```js
const moduleA = {
  state: () => ({ ... }),
  mutations: { ... },
  actions: { ... },
  getters: { ... }
}

const moduleB = {
  state: () => ({ ... }),
  mutations: { ... },
  actions: { ... }
}

const store = new Vuex.Store({
  modules: {
    a: moduleA,
    b: moduleB
  }
})

store.state.a // -> moduleA 的状态
store.state.b // -> moduleB 的状态
```

总结：

​	state：共享的状态

​		修改state状态：要使用 Vue.set(), 或 对象替换{ ...state.obj, newProp: 123 }

​	getters

​		对state中数据 统计，过滤，派生

​	mutation

​		只有这里直接操作 state 数据，并都是同步事务。store.commit() 触发方法

​	action

​		弥补mutation不能是异步的不足，store.dispatch()分发action事务



## 其他-拓展

#### 父子组件传值方式

> 除了　props, v-model, $emit/$on 
>
> ref: 父组件可以**通过引用获取调用子组件属性或方法**
>
> `$children`：获取到一个包含**所有子组件(不包含孙子组件)**的 `VueComponent` 对象数组，可以直接拿到子组件中所有数据和方法等
>
> `$parent`：获取到一个父节点的 `VueComponent` 对象，同样**包含父节点中所有数据和方法**等
>
> $attrs`：包含父作用域里除 class 和 style 除外的非 props 属性集合。通过 `this.$attrs` 获取父作用域中所有符合条件的属性集合，然后还要继续传给子组件内部的其他组件，就可以通过 `v-bind="$attrs" **将父组件属性传递给内部子组件**
>
> `$listeners`：包含父作用域里 `.native` 除外的监听事件集合。如果还要继续传给子组件内部的其他组件，就可以通过 `v-on="$linteners"`使用方式是相同的。**将父组件方法传递给内部子组件**
>
> $root: 访问根组件中的属性或方法,是根组件，不是父组件。$root**只对根组件有用**

- .sync

	类似于v-model语法糖，也是通过 $emit/$on 实现

	Parent.vue:

	```vue
	
	<template>
	    <child :page.sync="page"></child>
	</template>
	<script>
	export default {
	    data(){
	        return {
	            page:1
	        }
	    }
	}
	```

	Child.vue

	```vue
	<script>
	    export default {
	        props:["page"],
	        computed(){
	            // 当我们在子组件里修改 currentPage 时，父组件的 page 也会随之改变
	            currentPage {
	                get(){
	                    return this.page
	                },
	                set(newVal){
	                    this.$emit("update:page", newVal)
	                }
	            }
	        }
	    }
	</script>
	```

	

- provide/inject

	在父级注入，然后可以在该父级任意子孙级组件引用

	父级注入：

	```js
	// 父组件
	export default{
	    // 方法一 不能获取 methods 中的方法
	    provide:{
	        name:"oldCode",
	        age: this.data中的属性
	    },
	    // 方法二 不能获取 data 中的属性
	    provide(){
	        return {
	            name:"oldCode",
	            someMethod:this.someMethod // methods 中的方法
	        }
	    },
	    methods:{
	        someMethod(){
	            console.log("这是注入的方法")
	        }
	    }
	}
	```

	后代组件引用：

	```js
	export default{
	    inject:["name","someMethod"],
	    mounted(){
	        console.log(this.name)
	        this.someMethod()
	    }
	}
	```

	

#### $event

```html
使用场景
1、获取原生事件的 DOM 的事件对象
	<button @click="getData('自定义参数1','自定义参数2', $event)">按钮 </button>
	上面情况不写$event 拿不到原生事件对象，除非不传参，默认一个参数是event对象
	getData(a,b,e){
        
    }
2、事件注册所传的参数(子组件向父组件传值)
	在子组件中通过$emit注册事件，将数据作为参数传入，在父组件中通过$event接收
    
    父：
    	<template>
        	<Hello @aaa="aaa = $event" />
            {{aaa}}
        </template>
		<script>
			import Hello from './Hello.vue'
            export default {
                components: {
                    Hello
                },
                setup () {
                    const aaa = ref(null)
                    
                    return {
                        aaa
                    }
                }
            }
		</script>
        
    子：
		<template>
        	<button @click="$emit('aaa', 'hello')" />
        </template>
```

### v-model  v2版本

#### 多选日期组件写法1

```vue
<!--
 * @Description: 实现年份多选
 * @Author:  wyf
 * @Date: 2022-03-09 10:24:45
 * @LastEditTime: 2022-03-09 17:25:51
 * @LastEditors:  wyf
-->
<template>
   <div class="selectMonthBoxSquare" id="boxArea">
        <el-popover
            placement="bottom"
            width="290"
            trigger="focus"
            popper-class="my-selects-popper"
            :disabled="disabled"
        >
            <!-- 年份月份选择弹框 -->
            <div class="selectContentBox">
                <div class="contentArea"   v-if="DateList.length">
                    <!-- 标题 -->
                    <div class="title-tip" style="padding: 15px 0;border-bottom: 1px solid #e5e5e5;">
                        <div class="cursor" v-if="curIndex == DateList.length - 1" style="width: 15%;"><i class="el-icon-arrow-left" style="color:#ccc;"></i></div>
                        <div class="cursor" v-else @click="reduceYear" style="width: 15%;"><i class="el-icon-arrow-left" ></i></div>
                        <div>{{rangeYearString}}年</div>
                        <div class="cursor t-r" v-if="curIndex == 0" style="width: 15%;"><i class="el-icon-arrow-right"  style="color:#ccc;"></i></div>
                        <div class="cursor t-r" v-else @click="addYear" style="width: 15%;"><i class="el-icon-arrow-right" ></i></div>
                    </div>
                    <!-- 年份-->
                    <div class="conterList">
                        <el-checkbox-group class="flex flex-wrap"  v-model="optTime"  @change="onChange" >
                            <el-checkbox class="onSelect flex-x-center" v-for="(item) in DateList[curIndex]" :key="item" :label="item">
                            {{item}}年
                            </el-checkbox>
                        </el-checkbox-group>
                    </div>
                </div>
            </div>
            <!-- el-input输入框：readonly和clearable属性不能同时使用 -->
            <el-input slot="reference" class="inputStyle" v-model="inputValue" type="text" placeholder="请选择查询月份" readonly >
                <i slot="prefix" class="el-input__icon el-icon-date"></i>
                <!-- 清空图标：有内容的时候渲染出来，鼠标hover到input框的时候再显示出来（即：输入框有内容并且鼠标悬浮时显示该图标） -->
                <i slot="suffix" class="el-input__icon el-icon-circle-close clearIconStyle" v-if="showClear" style="position: relative;z-index: 9999999999;" @click.stop="resetMonth"></i>
            </el-input>
        </el-popover>
        
   </div>
</template>
<script>
export default {
    props: {
        value: {
            type: String,
            default: ''
        },
        disabled: {
            type: Boolean,
            default: false
        }
    },
    model: {
        prop: "value",//指定自己的pfoo属性接受数值
        event: "input"//指定自己的event1事件回送数据给父组件
    },
    data(){
        return {
            DateList: [], // 年份数组
            optTime: [], // 年份选中结果数组
            rangeYear: [], // 当前年份范围
            curIndex: 0, // 当前年份下标值
            inputValue: '', // 输入框的绑定值
            showClear: false, // 是否显示输入框右边的“清空”小图标
        }
    },
    mounted(){
        this.init();
    },
    computed: {
        rangeYearString: function () {
            return `${this.rangeYear[0]}~${this.rangeYear[1]}`
        }
    },
    watch: {
        value:{
            handler: function(val) {
                this.inputValue = val;
            },
            immediate: true
        },
        inputValue: {
            handler: function(val) {
                this.showClear = !!val && !this.disabled
            },
            immediate: true
        }
    },
    methods:{
        // 初始化数据，获取前20年， DateList
        init(){
            const _this = this;
            let optDate = this.getDateList();
            _this.DateList = optDate;
            setTimeout(()=> {
                this.optTime = this.value?this.value.split(',').map(ele=>+ele): []
            })
        },
        // 获取近XXX年年份列表，倒序排列，最新一年在最前面
        getDateList(){
            let Dates = new Date();
            let year = Dates.getFullYear();
            this.rangeYear = [year, year+9];
            let  optDate = [];
            let pointer = 0;
            let sub = 0;
            for( let i = year - 100; i <= year + 100; i++ ){
                pointer += 1
                if(!optDate[sub]) optDate[sub] = [];
                optDate[sub].push(i)
                // 设置当前年份页数
                if(i === year) {
                    this.curIndex = sub;
                }
                if(pointer == 10) {
                    pointer = 0
                    sub += 1
                }
            }
            return optDate.reverse()
        },
        // 左上角年份减少
        reduceYear() {
            const _this = this;
            // 如果已经是最后一年了，则年份不能再减少了
            if(_this.curIndex == _this.DateList.length - 1) return;
            // // 当前下标值+1，根据下标值获取年份值
            _this.curIndex += 1
            _this.rangeYear = [_this.rangeYear[0] - 10, _this.rangeYear[0] - 1]
        },
        // 左上角年份增加
        addYear() {
            const _this = this;
            // 如果已经是当前年份了，则年份不能再增加了
            if(_this.curIndex == 0) return;
            // 当前下标值-1，根据下标值获取年份值
            _this.curIndex -= 1
            _this.rangeYear = [_this.rangeYear[1] + 1,_this.rangeYear[1] + 10]
        },
        // 选择月份
        onChange(){
            const _this = this;
            this.inputValue = this.optTime.toString()
            this.$emit('input', this.inputValue)
        },
        resetMonth() {
            this.optTime = []
            this.inputValue = ''
            this.$emit('input', '')
        }
    }
}
</script>
<style lang="scss" scoped>
.selectContentBox {
    .title-tip {
        display: flex;
        justify-content: center;
        align-items: center;
    }
    .cursor {
        text-align: center;
    }
    .contentArea {
        width: 290px;
        color: #fff;
    }
    .conterList{
        .onSelect{
            width: 25% !important;
            margin: 20px 0 !important;
        }
        .columWidth {
            width: 33.33%;
        }
        .el-checkbox__input {
            display: none !important;
        }
        .el-checkbox__label {
            padding-left: 0px !important;
        }
    }

    .buttonBox {
        border-top: 1px solid #e5e5e5;
        padding: 10px 10px 10px 0;
    }
}

</style>
<style lang="scss">
    .my-selects-popper {
        background: #0a353b !important;
        .el-checkbox__input {
            display: none;
        }
    }
</style>
```

#### 多选日期组件写法2

```vue
<!--
 * @Description: 实现年份多选
 * @Author:  wyf
 * @Date: 2022-03-09 10:24:45
 * @LastEditTime: 2022-03-09 17:25:51
 * @LastEditors:  wyf
-->
<template>
   ...
</template>
<script>
export default {
    props: {
        value: {
            type: String,
            default: ''
        },
        disabled: {
            type: Boolean,
            default: false
        }
    },
    data(){
        return {
            DateList: [], // 年份数组
            optTime: [], // 年份选中结果数组
            rangeYear: [], // 当前年份范围
            curIndex: 0, // 当前年份下标值
            inputValue: '', // 输入框的绑定值
            showClear: false, // 是否显示输入框右边的“清空”小图标
        }
    },
    mounted(){
        this.init();
    },
    computed: {
        ...
    },
    watch: {
        value:{
            handler: function(val) {
                this.inputValue = val;
            },
            immediate: true
        },
        inputValue: {
            handler: function(val) {
                this.showClear = !!val && !this.disabled
            },
            immediate: true
        }
    },
    methods:{
        // 初始化数据，获取前20年， DateList
        init(){
            ...
        },
        // 获取近XXX年年份列表，倒序排列，最新一年在最前面
        getDateList(){
           ...
        },
        // 左上角年份减少
        reduceYear() {
           ...
        },
        // 左上角年份增加
        addYear() {
            ...
        },
        // 选择月份
        onChange(){
            const _this = this;
            this.inputValue = this.optTime.toString()
            this.$emit('update:input', this.inputValue)
        },
        resetMonth() {
            this.optTime = []
            this.inputValue = ''
            this.$emit('update:input', '')
        }
    }
}
</script>
<style lang="scss" scoped>
...
</style>
```



#### 组件使用

```html
写法一调用
<select-years :disabled="!isRenderTime"  v-model="dialogForm.jhnd"></select-years>
写法二调用
<select-years :disabled="!isRenderTime" :value.sync="dialogForm.jhnd" @update:value="dialogForm.jhnd = this.$event"></select-years>
```

