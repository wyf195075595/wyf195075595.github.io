---
title: react 基础知识
date: 2022-06-17 08:23:10
tags: 基础知识
categories: react
---
# react项目创建

## 1、创建项目

```js
npx create-react-app my-app
cd my-app
npm start
```

<!--more-->

## 2、组件

```js
import React,{useState,useEffect,useRef} from 'react';//任何组件必须引入react
//函数组件
//组件名称大写开头
function App(props){
    //响应式数据
    let [menuList,setMenuList] = useState([]);
    let myRef = useRef(null);
    //类似于生命周期函数
    useEffect(() => {
        console,log('ul 元素DOM',myRef.current);
        React.axios({
            url:'/menu/getMenuList',
            // method:'GET'
        }).then(res=>{
            if(res.data.data.length){
                setMenuList(res.data.data)
            }
        })
        return () => {
            
        };
    },[]);
    return(
    	<div>
        	我是组件App
        	<ul ref = {myRef}>
        	{
        		menuList.length && menuList.map(ele=>{
        			//key 只是在兄弟节点之间必须唯一
        			return <li key={ele.id}>{ele.title}</li>
        		})
        	}
            </ul>
        
        </div>
    )
}

//class组件
class Test extends React.Component {
    constructor(props) {
        super(props);
        //局部响应式数据
        this.state = {a:'Test'};
        // 为了在回调中使用 `this`，这个绑定是必不可少的
        this.test1 = this.test1.bind(this);
    }
    //生命周期钩子函数
    componentDidMount() {
  		console,log('div 元素DOM',this.refs.myRef);
    }
    //正常写法
    test1(a){
        this.setState({a})
    }
    //这是 *实验性* 语法。
    test2 = (a,e)=>{
        this.setState({a})
    }
    render(){
        
        
        return(
            <>
        	<div ref = 'myRef' onClick={this.test1.bind(this, 'xxx')}>我是组件{a}</div>
        	<div onClick={(e)=>this.test2('xxx',e)}>我是组件{a}</div>
		   </>
        )
    }
}


//两种组件可以相互嵌套使用，组件还能被作为参数传入
```

## 3、表单元素

```js
class EssayForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      value: '请撰写一篇关于你喜欢的 DOM 元素的文章.'
    };

    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleChange(event) {
    this.setState({value: event.target.value});
    //不确定键名时
    let name = event.target.name
    this.setState({
      [name]: value
    });
  }

  handleSubmit(event) {
    alert('提交的文章: ' + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          文章:
          <textarea value={this.state.value} onChange={this.handleChange} />
        </label>
        <input type="submit" value="提交" />
      </form>
    );
  }
}
```

## 4、路由

```html
//import { BrowserRouter as Router, Switch, Route,Link } from 'react-router-dom';
<Layout className="pageContent">
    //根路由
    <Router >
            <Layout >
            <Header style={{padding:'0'}}>
                <Head menuList={menuList}/>
            </Header>
            <Content>
                	//switch只会渲染匹配到的第一个子元素
                    <Switch >
                        <Route  path="/setup" component={SetUp}/>
                        <Route  path="/article" component={Article}/>
                        <Route  path="/articledetail" component={ArticleDetail}/>
                        <Route  path="/toPersonInfo" component={PersonInfo}/>
                        //exact 路由严格匹配
                        <Route  exact path="/" component={Article} />
                        <Route  component={NotFound} />
                    </Switch>
            </Content>
            <Footer>
                <Foot  />
            </Footer>
        </Layout>
        <Sider>
                <Route   component={Login}  dispatch = {dispatch} /> 
        </Sider>
    </Router>  

</Layout>

```

### 1、路由传参

1. link标签

	```js
	// 页面刷新存在 参数回显到地址栏 类似于get请求 不能传过大的数据
	pathname + search
	//A页面
	<Link to={{pathname: '/setting', search:'id=1'}}>jump --- search</Link>
	
	//B页面取参
	this.props.history.location.search
	```

	```js
	// 页面刷新不存在 参数不回显到地址栏 
	pathname + 任意值
	//A页面
	<Link to={{pathname: '/setting', abc:'id=1'}}>jump --- search</Link>
	
	//B页面取参
	this.props.history.location.abc
	```

	```js
	// 页面刷新存在 参数不回显到地址栏 
	pathname + state
	//A页面
	<Link to={{pathname: '/setting', state:{'id':1}}}>jump --- search</Link>
	
	//B页面取参
	this.props.history.location.state
	```

	```js
	// 动态路由后面加?表示可选，不加表示必选
	<Route path="/setting/:id?" component={Setting} />
	//A页面
	let id = 1;
	<Link to={{pathname: `/setting/${id}`}}>jump --- params</Link>
	// 取参
	//B页面
	this.props.history.match.params.id
	```

	> 注意【state 传参的方式只支持Browserrouter路由，不支持hashrouter】

2. 试试

## 



## Hooks

### useState

```react
创建一个响应式数据

eg1

import React, {useState} from 'react'

const LinkButton = ()=> {
    const [ like, setLike ] = useState(0);
    
    return (
    	<button onClick = {()=> {setLike(like + 1)}}>
        	{like}👍
        </button>
    )
}

eg2

import React, { useState} from 'react'

const LinkButton = ()=> {
    const [ obj, setObj ] = useState({like: 0, on: true});

    return (
    	<>
            <button onClick={()=> { setObj({...obj, like: obj.like + 1}) }}>
                {obj.like}👍
            </button>
            <button onClick={()=> { setObj({...obj, on: !obj.on}) }}>
                {obj.on? 'On': 'Off'}
            </button>
        </>
    )
}
```

### useEffect

```react
渲染后执行某操作
import React, {useEffect, useState} from 'react'

// 初始化，更新时调用
const LinkButton = ()=> {
    const [ obj, setObj ] = useState({like: 0, on: true});
    useEffect(()=> {
        document.title = `点击了${obj.like}次`
    })
    return (
    	<>
            <button onClick={()=> { setObj({...obj, like: obj.like + 1}) }}>
                {obj.like}👍
            </button>
            <button onClick={()=> { setObj({...obj, on: !obj.on}) }}>
                {obj.on? 'On': 'Off'}
            </button>
        </>
    )
}

// 清除副作用

const MouseTracker () => {
    const [ positions, setPositions] = useState({x: 0, y: 0});
    useEffect(()=> {
        const updateMouse = (e) => {
            setPositions({x: e.clientX, y: e.clientY})
        }
        document.addEventListener('click', updateMouse)
        // 清除副作用（每次更新都会再次绑定事件）
        reutrn () => {
            // 每次执行后在此清除副作用
            document.removeEventKistener('click', updateMouse)
        }
    })
}

// 随机狗狗图片
接口： https://dog.ceo/api/breeds/image/random
返回值：{"message":"https:\/\/images.dog.ceo\/breeds\/sheepdog-english\/n02105641_2138.jpg","status":"success"}

import React,{ useEffect, useState } from 'react'

const DogShow = () => {
    const [url, setUrl] = useState('');
    const [loading, setLoading] = useState(true)
    useEffect(() => {
        fetch('https://dog.ceo/api/breeds/image/random')
        .then((res)=> res.json())
        .then(res=> {
            console.log(res);
            if(res) {
                setUrl(res.message)
            }

        })
        .finally(()=>{
            setLoading(false)
        })
        return () => {
            
        };
       // 下面可以添加依赖，只有依赖变化才执行。如果依赖为空则只执行一次
       // 不写依赖，则 执行setUrl 又会触发更新，无限循环
    }, []);
    return (
        <>
            {
                loading? '🐕读取中': <img src={url} />
            }
        </>
    )
}


```

### 自定义hook

```react
// 猫猫图片
接口： http://api.thecatapi.com/v1/images/search?limit=1&category_ids=



// 获取鼠标的位置
const useMousePosition () => {
    const [ positions, setPositions] = useState({x: 0, y: 0});
    useEffect(()=> {
        const updateMouse = (e) => {
            setPositions({x: e.clientX, y: e.clientY})
        }
        document.addEventListener('mousemove', updateMouse)
        // 清除副作用（每次更新都会再次绑定事件）
        reutrn () => {
            // 每次执行后在此清除副作用
            document.removeEventKistener('mousemove', updateMouse)
        }
    })
    return positions
}

// 封装狗狗图片
const useURLLoader = (url)=> {
    const [url, setUrl] = useState('');
    const [loading, setLoading] = useState(true);
    useEffect(() => {
        fetch(url)
            .then(res=> res.json())
            .then(res=> {
            	setUrl(res.message)
            	setLoading(false)
            })
    }, [url])
    return [url, loading]
}

// 使用

const DogShowHook = () => {
    const { url, loading } = useURLLoader('https://dog.ceo/api/breeds/image/random')
    let style = {}
    return (
        <>
        	{loading ? <p>读取🐕中</p>: <img src={url} alt="dog" style={style} />}	
        </>
    )
}
```

### Hook 规则

```js
1、只在最顶层使用 Hook
2、只在 React 函数 中使用 Hook

拓展： useHooks.com
```



### HOC - Higher order component

```
高阶组件： 一个函数，接收一个组件作为参数，返回一个新的组件

```

## 在线笔记项目

### 原型图
![](https://raw.githubusercontent.com/wyf195075595/images/main/blog/%E4%BA%91%E7%AC%94%E8%AE%B0%E5%8E%9F%E5%9E%8B%E5%9B%BE.png)

### 功能分析

![](https://raw.githubusercontent.com/wyf195075595/images/main/blog/%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90.png)



### 引入字体库

```react
fortawesome

// 安装
	npm i @fontawesome/free-solid-svg-icons -S
	
	
// 引用
	import {FontAwesomeIcon} from '@fontawesome/react-fontawesome'
	import {faCoffee} from 'fontawesome/free-solid-svg-icons'
	
//使用

<FontAwesomeIcon icon={faCoffee}></FontAwesomeIcon>

```

### 内置类型检查

```react
-propTypes
v15.5 以上 需要单独安装 prop-types 库

// 引入
import PropTypes from 'prop-types'

const FileSearch = ({title, onFileSearch}) => {
    const [inputActive, setInputActive] =  useState(false);
    const [value, setvalue] = useState('');

    return (
        <div className='file-search-box'>
            <div className='input-box'>
              <Input autoFocus onPressEnter={onFileSearch} />
            </div>
            <Button shape="circle" size="middle"} icon={<CloseOutlined} />
        </div>
    )
}
// 组件类型检查
FileSearch.propTypes = {
    title: PropTypes.string,
    onFileSearch: PropTypes.func.isRequired
}
// 组件默认值
FileSearch.defaultProps = {
    title: '我的云文档'
}
```

### classnames

```react
// 一个简单的JavaScript工具有条件地一起加入类名

npm install classnames

// react 中使用
var classNames = require('classnames');

class Button extends React.Component {
  
  render () {
    var btnClass = classNames({
      btn: true,
      'btn-pressed': this.state.isPressed,
      'btn-over': !this.state.isPressed && this.state.isHovered
    });
    return <button className={btnClass}>{this.props.label}</button>;
  }
}
```

### 引入WangEditor

```react
// v5版本js动态设置初始化内容有点问题

需安装 @wangeditor/editor 和 @wangeditor/editor-for-react

// FileEditer.js
import React,{useState, useEffect} from 'react'
import './FileEditer.scss'
import '@wangeditor/editor/dist/css/style.css'
import { Editor, Toolbar } from '@wangeditor/editor-for-react'

export default function FileEditer() {
    const [editor, setEditor] = useState(null) // 存储 editor 实例
    const defaultContent = [] // 编辑器默认内容，空内容
    
    const toolbarConfig = {} // 菜单栏配置
    
    // 编辑器配置
    const editorConfig = {
        placeholder: '请输入内容...',
        onCreated: (editor) => {
            // 编辑器创建之后，记录 editor 实例，重要 ！！！ （有了 editor 实例，就可以执行 editor API）
            setEditor(editor)
        },
        onChange: (editor) => {
            // editor 选区或者内容变化时，获取当前最新的的 content
            console.log('changed', editor.children)
        }
    }
    
    // 组件销毁时，及时销毁 editor 实例，重要！！！
    useEffect(() => {
        return () => {
            if (editor == null) return
            editor.destroy()
            setEditor(null)
        }
    }, [editor])
    
    return (
        <div className='edit-wrap'>
            {/* 渲染 toolbar */}    
            <Toolbar
                editor={editor}
                defaultConfig={toolbarConfig}
                style={{ borderBottom: '1px solid #ccc',boxSize: 'border-box' }}
            />

            {/* 渲染 editor */}
            <Editor
                defaultConfig={editorConfig}
                defaultContent={defaultContent}
                style={{ height: 'calc(100% - 41px)' }}
            />
        </div>
    )
}
```

### 引入wangeditor  v4版本

```js
// Easy-mde 编辑器

// 安装
npm i wangeditor --save


```



### State设计原则

```js
1、最小化 State 原则
2、DRY - Dont Reapeat Yourself
3、有些数据可以根据已有 State 计算
4、使用多个 State 变量
```

### App  state 分析

```react
1、文件列表			
2、搜索后的文件列表
3、未保存的文件列表
4、已经打开的文件列表
5、当前被选中的文件

-所需数组
files: [{id: '1'},]
searchedFiles: [{id: '1'},..]
unsavedFiles:  [{id: '2'},...]
openedFiles:   [{id: '2'},...]
activeFile:    {id: '1',...}

-优化
  files: [{id: '1'},..]
  unsavedFileIDs: ['1','2']
  openedFileIDs: ['2']
  activeFileID: '1'
```
![](https://raw.githubusercontent.com/wyf195075595/images/main/blog/state%E6%95%B0%E6%8D%AE%E6%B5%81.png)

![](https://raw.githubusercontent.com/wyf195075595/images/main/blog/callbackflow.png)

