---
title: android 反编译
date: 2025-06-23 10:23:10
tags: android
categories: 反编译
---

[参考的学习教程](https://github.com/ZJ595/AndroidReverse/blob/main/Article/07%E7%AC%AC%E4%B8%83%E8%AF%BE%E3%80%81Sorry%EF%BC%8C%E4%BC%9AHook%E7%9C%9F%E7%9A%84%E5%8F%AF%E4%BB%A5%E4%B8%BA%E6%89%80%E6%AC%B2%E4%B8%BA-Xposed%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B(%E4%B8%8A)%E6%A8%A1%E5%9D%97%E7%BC%96%E5%86%99%EF%BC%8CApi%E8%AF%A6%E8%A7%A3.md)，已经fork到自己的github,课件资源存到百度云盘了

## 工具

### LSPosed

LSPosed 是一款基于 **Android 系统** 的 **Xposed 框架替代品**，用于在不修改 APK 文件的情况下改变系统和应用行为。它通过 Hook（钩子）机制拦截方法调用，实现功能增强、修改或扩展。

主要特点

1. **无需 Root**：支持在 **Magisk 环境** 下无 Root 运行（需要设备已解锁 Bootloader）。
2. **广泛兼容性**：兼容 Android 8.0 至 14 版本，对新系统支持更好。
3. **模块化设计**：通过安装不同模块实现各种功能（如微信防撤回、游戏修改等）。
4. **性能优化**：相比传统 Xposed 框架，内存占用更低，稳定性更高。

### Magisk

Magisk 是一款强大的 Android 开源工具，用于在不修改系统分区的情况下获取 **Root 权限** 并实现 **系统功能定制**。它通过独特的 "魔术修补" 技术，在不影响官方系统完整性的前提下提供高级权限，是目前 Android 自定义最受欢迎的工具之一。 **LSPosed** 是 Magisk 的一个强大的模块 

核心功能

1. **Root 权限管理**：安全获取 Root 权限，支持细粒度权限控制。
2. **模块系统**：通过安装模块扩展功能（如字体替换、性能优化等）。
3. **系统分区隔离**：避免直接修改系统文件，便于恢复和升级。
4. **隐藏 Root 状态**：在需要时向应用隐藏 Root 权限（如游戏防封）。

### 核心破解

**XAppDebug**

配合 **jadx-gui**（桌面端软件）可以调试 apk 包中的代码逻辑 

### **jadx-gui**

将一个apk打开，解析成 Smail 代码 ，文件可转换成 可读 java 代码，并配合 **XAppDebug** 调试代码逻辑

### 开发助手、算法助手

反编译的辅助工具软件

### Smail语法查询

寄存器语法查询

### MT/NP管理器

非常实用的反编译工具。	

### LSPatch

将安卓hook模块注入到app重新打包，在无root环境运行

### SimpleHook

提供界面化的 hook 注入，不需要手动编写 java hook，但是功能没手写hook 那样自由，支持修改变量，方法返回值，参数等

### IDA PRO 

Android 提供了 ndk 开发包，可将c/c++等汇编语言程序编译为 SO 文件（可在android环境运行），JNI(Java Native Interface)  **可让 Java 代码能够调用 SO 文件中的原生函数**

java

```java
// Java代码声明本地方法
public class NativeHelper {
    static {
        System.loadLibrary("native-lib"); // 加载SO文件
    }
    public native String stringFromJNI(); // 声明本地方法
}
```

c++

```c++
// C++代码实现JNI方法
#include <jni.h>
extern "C" JNIEXPORT jstring JNICALL
Java_com_example_myapp_NativeHelper_stringFromJNI(JNIEnv *env, jobject /* this */) {
    return env->NewStringUTF("Hello from C++");
}
```

使用这种方式 可以 提高性能 （音视频编解码（如 FFmpeg）、游戏物理引擎），加密防止逆向，跨平台友好

**而 IDA PRO 就是用来 反编译 so 文件的**

## 技巧

### Android studio 连接雷电模拟器

在此之前需要设置 网络桥接模式 拥有独立的ip 在 我的平板查看 ip ，确保与电脑可以相互ping 通.

```shell
\# 进入雷电模拟器安装目录 cd D:\LDPlayer  
# 根据实际路径修改
# 查看设备列表 可获取 adb 端口, 得到这个端口可以直接进行最后一步，不成功就手动设置端口
adb devices
# 设置模拟器的 ADB 端口（例如 5554） 
.\ldconsole.exe adb --index 0 --command "tcpip 5554" 
# 重启模拟器 
.\ldconsole.exe restart --index 0 
# 尝试连接 
adb connect 192.168.1.105:5554
```

### Xposed Hook

Xposed是一款可以在不修改APK的情况下影响程序运行的框架，基于它可以制作出许多功能强大的模块，且在功能不冲突的情况下同时运作。在这个框架下，我们可以编写并加载自己编写的插件APP，实现对目标apk的注入拦截等。

配合 Android studio 新建一个 Android 项目 ，编写 Hook 通过 xposedBridgeApi.jar包 和 LSPosed 软件 可以 调试 hook (启动demo之前，记得关掉算法助手的开关，不然可能没有日志显示)

常用API

#### 1.Hook变量



静态变量与实例变量：

- 静态变量（static）：类被初始化，同步进行初始化
- 非静态变量：类被实例化（产生一个对象的时候），进行初始化

静态变量

```java
final Class clazz = XposedHelpers.findClass("类名", classLoader);  
XposedHelpers.setStaticIntField(clazz, "变量名", 999);
```



实例变量

```java
final Class clazz = XposedHelpers.findClass("类名", classLoader);  
XposedBridge.hookAllConstructors(clazz, new XC_MethodHook() {  
    @Override  
    protected void afterHookedMethod(MethodHookParam param) throws Throwable {  
        super.afterHookedMethod(param);  
        //param.thisObject获取当前所属的对象
        Object ob = param.thisObject;  
        XposedHelpers.setIntField(ob,"变量名",9999);  
    }  
});
```



#### 2.Hook构造函数



无参构造函数

```java
XposedHelpers.findAndHookConstructor("com.zj.wuaipojie.Demo", classLoader, new XC_MethodHook() {
    @Override
    protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
        super.beforeHookedMethod(param);
    }
    @Override
    protected void afterHookedMethod(MethodHookParam param) throws Throwable {
        super.afterHookedMethod(param);
    }
});
```



有参构造函数

```java
XposedHelpers.findAndHookConstructor("com.zj.wuaipojie.Demo", classLoader, String.class, new XC_MethodHook() {
    @Override
    protected void beforeHookedMethod(MethodHookParam param) throws Throwable {
        super.beforeHookedMethod(param);
    }
    @Override
    protected void afterHookedMethod(MethodHookParam param) throws Throwable {
        super.afterHookedMethod(param);
    }
});
```



#### 3.Hook multiDex方法

当方法超过 65536 个时 会生成新的 dex 文件

```java
XposedHelpers.findAndHookMethod(Application.class, "attach", Context.class, new XC_MethodHook() {  
    @Override  
    protected void afterHookedMethod(MethodHookParam param) throws Throwable {  
        ClassLoader cl= ((Context)param.args[0]).getClassLoader();  
        Class<?> hookclass=null;  
        try {  
            hookclass=cl.loadClass("类名");  
        }catch (Exception e){  
            Log.e("zj2595","未找到类",e);  
            return;        
        }  
        XposedHelpers.findAndHookMethod(hookclass, "方法名", new XC_MethodHook() {  
            @Override  
            protected void afterHookedMethod(MethodHookParam param) throws Throwable {  
            }        
        });  
    }  
});
```



#### 4.主动调用



静态方法:

```java
Class clazz = XposedHelpers.findClass("类名",lpparam.classLoader);
XposedHelpers.callStaticMethod(clazz,"方法名",参数(非必须));
```



实例方法:

```java
Class clazz = XposedHelpers.findClass("类名",lpparam.classLoader);
XposedHelpers.callMethod(clazz.newInstance(),"方法名",参数(非必须));
```



#### 5.Hook内部类



内部类:类里还有一个类class

```java
XposedHelpers.findAndHookMethod("com.zj.wuaipojie.Demo$InnerClass", lpparam.classLoader, "innerFunc",String.class,  new XC_MethodHook() {  
    @Override  
    protected void beforeHookedMethod(MethodHookParam param) throws Throwable {  
        super.beforeHookedMethod(param);  

    }  
});
```



#### 6.反射大法



```java
Class clazz = XposedHelpers.findClass("com.zj.wuaipojie.Demo", lpparam.classLoader);
XposedHelpers.findAndHookMethod("com.zj.wuaipojie.Demo$InnerClass", lpparam.classLoader, "innerFunc",String.class,  new XC_MethodHook() {  
    @Override  
    protected void beforeHookedMethod(MethodHookParam param) throws Throwable {  
        super.beforeHookedMethod(param);  
        //第一步找到类
        //找到方法，如果是私有方法就要setAccessible设置访问权限
        //invoke主动调用或者set修改值(变量)
        Class democlass = Class.forName("com.zj.wuaipojie.Demo",false,lpparam.classLoader);  
        Method demomethod = democlass.getDeclaredMethod("refl");  
        demomethod.setAccessible(true);  
        demomethod.invoke(clazz.newInstance());  
    }  
});
```



#### 7.遍历所有类下的所有方法



```java
XposedHelpers.findAndHookMethod(ClassLoader.class, "loadClass", String.class, new XC_MethodHook() {  
    @Override  
    protected void afterHookedMethod(MethodHookParam param) throws Throwable {  
        super.afterHookedMethod(param);  
        Class clazz = (Class) param.getResult();  
        String clazzName = clazz.getName();  
        //排除非包名的类  
        if(clazzName.contains("com.zj.wuaipojie")){  
            Method[] mds = clazz.getDeclaredMethods();  
            for(int i =0;i<mds.length;i++){  
                final Method md = mds[i];  
                int mod = mds[i].getModifiers();  
                //去除抽象、native、接口方法  
                if(!Modifier.isAbstract(mod)  
                    && !Modifier.isNative(mod)  
                    &&!Modifier.isAbstract(mod)){  
                    XposedBridge.hookMethod(mds[i], new XC_MethodHook() {  
                        @Override  
                        protected void beforeHookedMethod(MethodHookParam param) throws Throwable {  
                            super.beforeHookedMethod(param);  
                            Log.d("zj2595",md.toString());  
                        }  
                    });  
                }  
  
           }  
        }  
  
    }  
});
```



#### 8.Xposed妙用



字符串赋值定位:

```java
XposedHelpers.findAndHookMethod("android.widget.TextView", lpparam.classLoader, "setText", CharSequence.class, new XC_MethodHook() {  
    @Override  
    protected void beforeHookedMethod(MethodHookParam param) throws Throwable {  
        super.beforeHookedMethod(param);  
        Log.d("zj2595",param.args[0].toString());  
		if(param.args[0].equals("已过期")){  
		    printStackTrace();  
		}
    }  
});
private static void printStackTrace() {  
    Throwable ex = new Throwable();  
    StackTraceElement[] stackElements = ex.getStackTrace();  
    for (int i = 0; i < stackElements.length; i++) {  
        StackTraceElement element = stackElements[i];  
        Log.d("zj2595","at " + element.getClassName() + "." + element.getMethodName() + "(" + element.getFileName() + ":" + element.getLineNumber() + ")");  
    }  
}
```



点击事件监听:

```java
Class clazz = XposedHelpers.findClass("android.view.View", lpparam.classLoader);
XposedBridge.hookAllMethods(clazz, "performClick", new XC_MethodHook() {  
    @Override  
    protected void afterHookedMethod(MethodHookParam param) throws Throwable {  
        super.afterHookedMethod(param);  
        Object listenerInfoObject = XposedHelpers.getObjectField(param.thisObject, "mListenerInfo");  
        Object mOnClickListenerObject = XposedHelpers.getObjectField(listenerInfoObject, "mOnClickListener");  
        String callbackType = mOnClickListenerObject.getClass().getName();  
        Log.d("zj2595",callbackType);  
    }  
});
```



改写布局:

```java
XposedHelpers.findAndHookMethod("com.zj.wuaipojie.ui.ChallengeSixth", lpparam.classLoader,  
        "onCreate", Bundle.class, new XC_MethodHook() {  
    @Override  
    protected void afterHookedMethod(MethodHookParam param) throws Throwable {  
        super.afterHookedMethod(param);  
        View img = (View)XposedHelpers.callMethod(param.thisObject,  
                "findViewById", 0x7f0800de);  
        img.setVisibility(View.GONE);  
  
    }  
});
```




