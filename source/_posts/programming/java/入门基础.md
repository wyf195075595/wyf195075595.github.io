---
title: java基础
date: 2023-01-09 13:00:00
tags: java基础
categories: java
---

## java 特性

### Java 程序的版本

> java SE (标准版)
>
> java EE（企业版）
>
> java ME（精简版）

### java 程序可移植性

> 什么是可移植性？
>
> java 程序可以做到一次编译，到处运行。可就是说可以运行到windows,linux等操作系统上。这个被称作Java程序的可移植性，或者叫跨平台。
>
> 如何实现呢？
>
> Windows操作系统于Linux操作系统的内核肯定不一样，系统执行指令的而方式也不一样。 Java程序不能直接和系统打交道，因为Java程序只有一份。操作系统原理都不同
>
> 解决：
>
> sum团队想到了一个办法，他们让Java程序运行在一台虚拟的计算机中，这个虚拟计算机叫Java虚拟机，简称JVM。Java虚拟机再和底层操作系统打交道。
>
> 这个虚拟机不能直接安装，而是通过安装适合自己操作系统的 **java jdk** 来实现的

### Java 的加载与执行

> 编译阶段主要任务是检查 Java 源程序是否符合 Java 语法（不进行运算），符合则生成正常字节码文件 (xxx.class)。不符合则无法生成字节码文件

.java -> .class -> 	类装载器 -> java 虚拟机（JVM） -> 操作系统 -> 硬件平台

<!--more-->

**前两步为编译阶段，后面为运行阶段。两步操作可以在不同系统执行**

> 1. .java 是 java 程序源文件（源代码）必须符合Java 编码 规范
>
> 2. class 编译后的文件（字节码文件），使用 javac 编译源文件生成
>
> 	javac 是一个java编译工具/命令，一个Java 源文件可编译生成多个 .class 文件。
>
> 	语法：javac java源文件路径
>
> 	字节码文件是最终要执行的文件，所以删除Java源文件也不影响Java程序运行效果。但一般不删除源文件，以防需要修改。
>
> 	class 文件拷贝到其他操作系统也是可以运行的
>
> 3. 安装jdk后除了自带 javac.exe, 还有一个工具/命令 java.exe，主要负责运行阶段
>
> 	语法：java 类名
>
> 	例如：硬盘上有一个 A.class ,那么执行 java A。运行程序不要带 .class
>
> 4. 运行阶段
>
> 	在DOS窗口运行：java A
>
> 	Java.exe 命令会启动Java虚拟机（JVM），JVM 会启动类加载器ClassLoader 去硬盘上搜索 A.class文件，找到文件则将该字节码文件装载到JVM当中。JVM然后将A.class字节码文件解释成 二进制10101010这样的数据，最后由操作系统执行二进制文件和底层平台经行交互。
>
> 

### 安装jdk,jdk,jre,jvm 关系

- jdk	开发工具包,可单独安装，安装时会自带安装jre
- jre     开发运行环境，包括 jvm，可单独安装
- jvm    Java虚拟机

### jdk 目录介绍

> bin目录： 里面存放了很多命令，如 javac.exe,java.exe
>
> db目录：
>
> jre目录：自带的开发运行环境
>
> lib目录：
>
> include目录:

### 环境变量

- 系统环境变量 path

	可以通过配置 path,让命令在DOS窗口任意 目录下使用，相当于系统全局变量

- java 环境变量 classpath, 不配也没事（默认当前路径）

	默认ClassLoader 在当前目录路径下加载 xxx.class 字节码，配置classpath 可以给 ClassLoader 类加载器指定路径。更改默认指定路径

	配置 **classpath=.**	，相当于指定默认目录就是当前路径



### Java 注释

> 工具  javadoc.exe 可以将注释中的文字添加到帮助文档中。注释跟 js 一样

### Java SE类库的源码位置？

- SE库字节码：C:\Program Files\Java\jdk1.7.0_51\jre\lib\rt.jar
- SE库源码：C:\Program Files\Java\jdk1.7.0_51\src.zip

### 编码方式

> Java 语言采用 Unicode 编码方式，实际开发中使用 utf-8 较多

javac xxx.java 编译错误： 编码GBK的不可映射字符

解决方法：

以这种格式对文件经行重新编译	

javac -encoding utf-8 xxx.java

## Java 语法

### public class 和 class 的区别

- 一个Java源文件当中可以定义多个class
- 一个Java源文件当中 public class 不是必须的
- 一个class会定义生成一个 xxx.class字节码文件
- 一个Java源文件当中定义公开的类的话，只能有一个，并且该类必须和Java源文件名称一致。
- 每一个class当中都可以编写main方法，都可以设置程序入口。要执行B.class 中的main方法，执行 java B。如果B中没有main主方法，会报错

### 标识符

> Java语言中的标识符。

#### 什么是标识符？

在Java源码程序中，可以自己命名的单词都是标识符。

如：类名，方法名，常量名，接口名...

#### 标识符的命名规则？

- 一个合法的标识符只能由 数字，字母，下划线_，美元符号$ 组成，不能有其他符号。

- 不能数字开头

- 严格区分大小写
- 关键字不能用
- 理论上无长度限制

#### 标识符的命名规范？

只是一种规范，不输入语法，不遵守规范编译也可以通过。但是不方便他人理解代码

- 最好见名知意
- 遵守驼峰命名
- 类名，接口名：首字母大写（大驼峰
- 变量，方法名：首字母小写（小驼峰
- 常量名：全部大写



### 关键字

在Java中关键字都是小写

| class   | extend | implement | interface | important |
| ------- | ------ | --------- | --------- | --------- |
| package | break  | case      | continue  | default   |
| do      | if     | else      | for       | return    |
| switch  | while  | false     | true      | ...       |



### 字面值

> java 语言中所有字符串类型字面值必须使用双引号括起来，双引号是英文的
>
> Java 语言中所有的字符型字面量必须使用单引号括起来，单引号是英文的

- 10，1200
- 3.14
- "abc","123"  属于字符串
- 'a','1','人'  属于字面值
- true,false



### 变量

> 变量要求储存的具体的“数据”必须和变量的“数据类型”一致，当不一致的时候编译报错

#### 数据类型的作用？

- 不同数据类型底层分配不同大小的空间
- 数据类型是指导程序运行阶段应该分配多大的内存空间

#### 声明、定义变量的语法格式：

**数据类型 变量名**

#### 变量的分类：

- 局部变量

	在方法体当中声明的变量叫局部变量

- 成员变量

	在方法体外【类体之内】声明的变量叫做成员变量

**不同作用域下变量名可以相同**，Java 遵循就近原则 



### 数据类型

**基本数据类型**

1. 整数型 int，byte，short，long
2. 浮点型 float，double
3. 布尔型 boolean
4. 字符型 char 【表示现实中的文字，通过ASC码表转换】

#### 八种基本数据类型占用空间大小：

| 基本数据类型 | 占用空间大小(byte) | 取值范围                                | 默认值 |
| ------------ | ------------------ | --------------------------------------- | ------ |
| byte         | 1                  | -2^7~2^7-1(-128,127)                    | 0      |
| short        | 2                  | -2^15~2^15-1(-32768,32767)              | 0      |
| int          | 4                  | -2^31~-2^31-1                           | 0      |
| long         | 8                  | -2^63~2^63-1                            | 0L     |
| float        | 4                  | 大约±3.40282347E+38F(有效位15)          | 0      |
| double       | 8                  | 大约±1.79769313486231570E+308(有效位15) | 0.0    |
| boolean      | 1                  | true/false                              | false  |
| chart        | 2                  | 0~2^16-1(0, 65535)                      | \u0000 |

> 字节（byte）：
>
> 1 byte = 8 bit 【一个字节=8个比特位】1个比特位表示一个二进制位：1/0
>
> 1 KB = 1024 Byte
>
> 1 MB = 1024 KB
>
> 1 GB = 1024 MB
>
> byte 类型最大值： 2的7次方 - 1，127
>
> byte 类型最小值：-128
>
> byte 类型可以表示 256 个不同的数字

#### 关于八种基本数据类型的默认值：**一切向0看齐**

> 变量遵守这个语法：必须先声明，再赋值，才能访问。
>
> 成员变量没有手动赋值系统默认会赋值，但是局部变量不会

**引用数据类型**

字符串 “abc” 不属于基本数据类型，属于 “引用数据类型”，字符属于基本数据类型：

#### char 与 转译字符

> chart 支持 中文('中')，支持转义字符（'\n'）, 使用单引号括起来，

```java
// 这个输出命令会换行
System.out.println()
// 这个不会换行
System.out.print()
```

#### 整数型

> Java 语言当中的 **"整数型字面量值"被默认当作 int 类型来处理**。要让这个 "整数字面量值"后面添加 **l/L** ,建议使用大写**L**

**整数字面值的三种表示方式：**

1. 十进制：是一种缺省默认的方式
2. 八进制：需要以0开始
3. 十六进制：需要以0x开始

**类型转换**

> int 是小容量，long 类型是大容量。小容量可以自动转换成大容量，称为自动类型转换机制

```java
// 1、可以自动转换为大容量
int x = 123;

long y = x;

// 2、编译出错
long z = 2147483648; 

// 2147483648 字面量一开始会被当作int类型4个字节处理，但是这个字面值超出了int范围，所以报错

// 解决
long z = 2147483648L;

// 这样一开始字面量就会被当作long类型处理


// 3、大容量转换小容量需要强制转换，但是运行阶段可能损失精度（慎用）
// 转换原理：将原始二进制数据前 32个比特（4字节）去掉

int y = (int)z;

// 4、int 转换为byte类型，只要不超出byte存储范围不需要强制转换 
byte b = 127;
byte c = 128'// 编译出错

```



#### 浮点型

> 浮点型存储的值都是近似值，现实世界中有些数字是无限循环小数，计算机存储资源有限，所以只能存储近似值
>
> float 单精度【4个字节】
>
> double 双精度【8个字节，精度较高】
>
> 对于财务类型软件，double精度还是过低，所以Java提供了另一个引用类型： Java.math.bigDecima
>

在Java语言中，所有的浮点型字面值【3.0】，默认被当作 double 类型来处理，要想该字面值当作 float 类型来处理，需要在字面值后面添加 F/f;

```java
double d = 3.0;

float f = 5.1;// 编译错误
// 5.1 默认是double类型大容量， float 是单精度小容量，需要强制转换符

float f = (float)5.1;// 强制类型转换
float f = 5.1f;// 没有强制转换
```



#### 布尔值

> 只有两个值：true,false.
>
> 底层存储的时候Boolean类型占用1个字节，因为实际存储的时候false底层是0，true底层是1
>
> 主要使用在逻辑运算和条件控制语句中



#### 类型转换

> 1. 八种基本数据类型当中，除了**Boolean**类型其他类型都能互相转换
>
> 2. 小容量向大容量转换，称为自动类型转换，容量从小到大：
>
> 	byte < (short = char) < int < long < float < double
>
> 	任何浮点类型不管占用多少个字节，都是比整数型容量大
>
> 3. 小容量转大容量，必须加强制转换符，编译才能通过，但是运行阶段可能损失精度，慎用
>
> 4. 当整数字面量没有超出**byte，short，char**的取值范围，可以直接赋值给**byte，short，char**类型的变量
>
> 5. **byte，short，char**混合运算时，各自先转换成**int**类型在做运算
>
> 6. 多种数据类型混合运算，先转换成容量最大的那种类型再做运算
>
> 	
>
> 	**编写.java文件只考虑编译，不考虑运行**



#### 运算符

| 算数运算符       | +、-、*、/、++、--、%                                        |
| ---------------- | ------------------------------------------------------------ |
| 逻辑运算符       | &(与)、(或)、~(非)、^(异或)、&&(短路与)、\|\|(短路或)        |
| 关系运算符       | <、<=、>=、==、!=                                            |
| 布尔运算符       | &&、\|\|、\|、&、！                                          |
| 位运算符         | &(与)、\|(或)、~(非)、^(按位异)、>>(右移)、>>>(右移，左边空出的位0填充)、<<(左移) |
| 赋值类运算符     | =、+=、-=、*=、/=、%/                                        |
| 字符串连接运算符 | +                                                            |
| 条件运算符       | ?:                                                           |
| 其他运算符       | instanceof、new                                              |

**逻辑运算符**

- 逻辑运算符 要求两边的算子都是 真/假（布尔类型），且最终运算结果也是一个布尔类型

	异或（两边的算子只要不一样，结果就是 true）

- 短路与和逻辑与的运算结果相同，只不过短路与存在短路现象

- 短路或和逻辑或的运算结果相同，只不过短路或存在短路现象

**赋值运算符**

> 扩展类的赋值运算符，不改变运算结果类型，假设最初这个变量类型是 byte 类型，无论怎么进行追加，追减，最终该变量的数据类型还是byte类型

+运算符 在Java中的两个作用：

- 加法运算，求和
- 字符串的连接运算

当 "+" 运算符两边的数据都是字符串，一定是字符串连接运算。

- 数字 + 数字 --> 数字
- 数字 + "字符串" ---> "字符串" 【字符串连接】

在一个表达式中可以出现多个 "+" 号，如果没有 括号，那么就是从左到右依次运算



## 控制语句

Java控制语句可以分为7种

- 控制选择结构语句

	- if,else 括号中接受一个Boolean
	- switch 括号中接受一个 int/String

- 控制循环结构语句

	- for
	- while
	- do while

- 改变控制语句顺序

	- break 

		作用在for,while,do..while

	- continue



## 方法

> 语法结构：
>
> [修饰符列表] 返回值类型 方法名 (形参参数列表) {
>
> ​	方法体：
>
> }
>
> 返回值类型可以是基本类型也可以是引用类型，当返回类型是viod时，方法体不能 使用 return 语句 返回值
>
> 修饰符列表 统一写成： public  static

1. 对于方法的修饰符列表中有 static 关键字的：在方法体种调用时可以省略**类名.** 

2. 建议一个Java源文件当中只定义一个 class，清晰易读

3. 方法的内存分配情况

	![image-20230111111814126](https://raw.githubusercontent.com/wyf195075595/images/main/blog/image-20230111111814126.png)

### 方法的重载

> 同一个类中功能相似的方法可以共用同一个方法名，然后根据传入参数类型的不同来调用不同的方法

**什么条件满足之后构成方法重载？**

- 在同一个类
- 方法名相同
- 参数列表不同
	- 数量不同
	- 顺序不同
	- 类型不同

**方法重载和什么有关，和什么没有关系？**

- 方法重载和方法名+参数列表有关系
- 方法重载和返回值类型无关
- 方法重载和修饰符无关

```java
class OverloadTest1 {
    public static void main(String[] args) {
        int a = sum(1, 2);// 3
        double b = sum(1.0, 2.0);// 3.0
        long c = sum(1L, 2L);// 3L
    }
    public static int sum(int a, int b) {
        return a + b
    }
    public static double sum(double a, double b) {
        return a + b
    }
    public static long sum(long a, long b) {
        return a + b
    }
}
```

### 方法的递归

> 方法自调用就是递归

```java
// 乘法递归
public static int chen(int n) {
    if (n == 1) {
        return 1;
    }
    return n * chen(--n);
}
```



## 面向对象

> 面向对象的三大特征：
>
> 1. 封装
> 2. 继承
> 3. 多态
>
> 所有面向对象的编程语言都有这三大特征。
>
> 1. 面向对象的分析：OOA
> 2. 面向对象的设计：OOD
> 3. 面向对象的编程：OOP

### 对象的创建和使用

![image-20230111154018456](https://raw.githubusercontent.com/wyf195075595/images/main/blog/image-20230111154018456.png)

```java
public class OOTest {
    public static void main(String[] args) {
        //
        int i = 10;
        
        /*
        	通过一个类可以实例化N个对象
        	语法： new 类名();
        	new 运算符作用是创建对象，在JVM堆内存中开辟新的内存空间
        	方法区内存：类加载时，class字节码代码片段被加载到该内存空间
        	栈内存（局部变量）：方法代码执行时，会给该方法分配栈内存空间，压栈
        	堆内存：new 的对象在堆内存中储存
        	
        	Student 是个引用数据类型，s 是 变量，new Student() 是一个学生对象
        	什么是引用？
        	引用是一个变量，只不过这个变量中保存了另一个Java对象的内存地址
        	
        	访问实例变量的语法格式：
        	读取数据：引用.变量名
        	修改数据：引用.变量名 = 值
        	
        	不能直接通过 Student.no 访问
        */
        Student s = new Student();
        
        s.no = 10;
        
    }
}

public class Student {
    // 学号
    int no;
    
    // 姓名
    String name;
    
    // 年龄
    int age;
    
    // 性别
    boolean sex;
    
    // 住址
    String addr;
}
/*
	成员变量没有赋值，则赋默认值， 引用类型默认值为 null
	
*/
```

### 空指针异常

> 空引用访问“实例”相关数据一定会出现空指针异常
>
> java.lang.NullPointerExption

### 封装

> 封装的步骤：
>
> 1. 所有属性私有化，使用 private 关键字进行修饰，修饰的数据只能在本类中访问
>
> 2. 对外提供简单的操作入口，如：读取和修改
>
> 3. set,get方法命名规范：
>
> 	- public void setAge (int a) {
>
> 		​	age = a;
>
> 		}
>
> 	- public int getAge () {
>
> 		​	return age;
>
> 		}
>
> 	- 调用：
>
> 		对于 有 static 修饰的方法采用 类名.方法名(实参)
>
> 		对于没有 static 修饰的方法采用 引用.方法名(实参)

```java
public class User {
    String name = "zhang san";
    // 把属性设置私有化
    private int age = 20;
    private String address = "somewhere interesting";

    public static void main(String[] args) {

    }

    public void setAge(int age) {
        this.age = age;
    }

    public int getAge() {
        return age;
    }
}
```



### 构造方法

> 1. 构造方法又被称为构造函数/构造器/Constructor
>
> 2. 构造方法语法结构：
>
> 	[修饰符列表] 构造方法名(形式参数列表) {
>
> 	​	构造方法体;
>
> 	}
>
> 3. 普通方法语法结构
>
> 	[修饰符列表] 返回值类型 方法名(形式参数列表) {
>
> 	​	方法体;
>
> 	}
>
> 4. 当一个类没有定义构造方法，系统默认给该类提供一个无参构造函数，称 缺省构造器
>
> 5. 构造方法除了 new 时调用，还可以手动调用 this()
>
> 	```java
> 	public class User {
> 	    int year;
> 	    int month;
> 	    int day;
> 	    public User(int year, int month, int day ) {
> 	        this.year = year;
> 	        this.month = month;
> 	        this.day = day;
> 	    }
> 	    // 无参数时调用次构造方法，默认设置日期 2020 12 12
> 	    public User() {
> 	        this(2020, 12, 12);// 这种语法只能出现在构造函数第一行，类似于 super
> 	    }
> 	}
> 	```
>
> 	



### this 关键字

> 关于Java中的this关键字

1. this是一个引用，this是一个变量，this变量中保存了内存地址指向自身，this存储在JVM堆内存Java对象内部

2. this 不能使用在带有static的方法中

	那么在 static 方法中怎么访问成员变量？

	- 方法中实例化对象获取引用访问
	- 通过参数将实例传入
	- 用 static 修饰成员变量，但在 非static 方法中不能用 this 访问只能用 **类名.属性名**



### static 关键字

> 静态变量：在类加载时就初始化，不需要创建对象**内存**就在**方法区**开辟了
>
> - static 关键字修饰的 属性，方法代表 类级别的和具体对象无关。需要使用 类名调用,引用方式也能调用【不建议】
>
> - 非 static 关键字修饰的 属性，方法 代表对象级别的。需要引用去调用

可以使用 static 关键字来定义 **静态代码块**

1、语法格式：

```java
static {
    java 语句;
}
```

2、静态代码在类加载时执行，并只执行一次



### 继承

> 关于Java 语言中的继承：

1. 继承是面向对象的三大特征之一,三大特征分别是：封装，继承，多态

2. 继承 **"基本"** 作用是：代码复用。但是继承 最重要 的作用是：有了继承才有以后"方法的覆盖"和多态机制。

3. 继承语法格式：

	```java
	[修饰符列表] class 类名 extends 父类名 {
		类体 = 属性 + 方法
	}
	```

4. Java 语言当中的继承只支持单继承，一个类不能同时继承很多类，只能继承一个类

5. 关于继承中的一些术语：

	B类继承A类，其中：

	​	A类称为：父类，基类、超类、superclass

	​	B类称为: 子类，派生类、subclass

6. Java语言中子类继承父类都继承哪些数据呢？

	- 私有的不支持

	- 构造方法不支持
	- 其他数据都支持

7. 虽然Java语言只支持单继承，但是一个类也可以简洁继承其他类，例如：

	```java
	C extends B {}
	B extends A {}
	A extends T {}
	// C 直接继承B类，但是C类直接继承T、A类。
	```

8. Java语言中假设一个类没有显示的继承任何类，该类默认继承 JavaSE 库当中提供的 Java.lang.Object类。



### 方法的覆盖

> Java 语言中方法的重载的条件
>
> - 在同一个类当中
> - 方法名相同
> - 参数列表不同：类型，顺序，个数至少一个不同
>
> 1. 方法重载和什么无关？
> 	- 和方法的而返回值类型无关
> 	- 和方法修饰符列表无关



> Java 语言中方法的覆盖
>
> 1. 方法覆盖在什么时候使用？
>
> 	**当父类方法无法满足子类的业务需求时，子类有必要重写聪父类继承的方法**
>
> 2. 什么条件满足之后构成方法重载？
>
> 	- 方法覆盖发生在具有继承关系的父子类之间
> 	- 返回值类型相同，方法名相同，形参列表相同
> 	- 访问权限不能更低 【protected -> public】
> 	- 抛出异常不能更多，可以更少
>
> 3. 方法覆盖和什么无关？
>
> 	- 和方法的而返回值类型无关
> 	- 和方法修饰符列表无关

1. 私有方法不能继承，所以不能覆盖。
2. 构造方法不能继承，所以不能覆盖。
3. 静态方法不存在覆盖。因为是通过类名访问的，父子类名肯定不同
4. 覆盖只针对方法，不谈属性

```Java
// 方法的覆盖

public class Animal {
 // 动物都是可以移动的
    public void move() {
        System.out.println("动物在移动");
    }
}

// 猫科类
public class Cat extends Animal {
    public void move() {
        System.out.println("猫在走猫步");
    }
    // 抓老鼠
    catchMouse() {
        System.out.println("猫抓老鼠")
    }
}
```



### 多态

> 语法机制：
>
> Cat 继承 Animal，Bird 继承 Animal。Cat 和 Bird 没有任何继承关系。
>
> 关于多态涉及的几个概念：
>
> - 向上转型
> 	- 子类型 --> 父类型	自动类型转换
> - 向下转型 
> 	- 父类型 --> 子类型	强制类型转换【加强制类型转换符】
> - 转型的前提是拥有继承关系

![image-20230112162203837](https://raw.githubusercontent.com/wyf195075595/images/main/blog/image-20230112162203837.png)

```java
Animal a1 = new Cat();// 向上转型，编译过，一定能运行

a1.move();// 猫在走猫步

/*
	编译不通过，
	因为 a1 是 Animal类型，而Animal类型中不存在找老鼠方法。
	此时想要调用 catchMouse 方法，需要将 a1 强制转换为 Cat.
	向下转型：当调用的方法是子类特有的，父类中不存在的，必须进行向下转型
*/
// a1.catchMouse();
Cat c1 = (Cat)a2;
c1.catchMouse();

/*
	此语法编译通过，但是运行会异常
	因为a1 实际引用是 Cat,而 Cat 与Bird 不存在任何继承关系，由此出现著名异常：
		java.lang.ClassCastException
		类型转换异常，这种异常总是在 "向下转型的时候"会发生。
		
		
	解决向下转型错误：
		使用 instanceof 运算符 解决
		语法格式：	（引用 instanceof 数据类型名）
		eg: a instanceof Animal
			true: a这个引用指向对象是一个 Animal 类型
			false: a这个引用指向对象不是一个 Animal 类型
	
*/

// Bird b1 = (Bird)a1;// 向下转型，编译过，可能运行错误

// 解决：
if(a1 instanceof Bird) {
    Bird b1 = (Bird)a1;
}
```

#### 多态在实际开发中的作用：

> 分析： 主人喂养宠物这个场景需要经行类型抽象：
>
> - 主人【类】
> 	- 主人可以喂养宠物，所有主人都有这个动作
> - 宠物【类】
> 	- 宠物可以吃东西，所有宠物都有吃东西的这个动作

- 降低程序耦合度，提高程序扩展力，能使用多态尽量使用多态。父类型引用指向子类型对象

核心： 面向抽象编程，不要面向具体编程

不使用多态

```java
// 主人类
public class Master {
    /*
    	这种方式没有使用多态，每次加一个宠物就要新增一个方法
    */
    public void fead (Cat c) {
        c.eat();
    }
    public void fead (Dog c) {
        c.eat();
    }
}

public class Cat {
    
    public void eat () {
        System.out.println("猫在吃饭饭")
    }
}

public class Dog {
    
    public void eat () {
        System.out.println("狗在吃饭饭")
    }
}


public class Test {
    public static void main(String[] args) {
        // 创建主人
        Master m1 = new Master();
        // 创建猫
        Cat c1 = new Cat();
        // 主人喂猫
        m1.fead(c1);
        
        // 创建狗
        Dog d1 = new Dog();
        // 主人喂狗
        m1.fead(d1);
    }
}
```

使用多态

```java
// 主人类
public class Master {
    /*
    	使用多态，pet 是一个父引用
    	耦合度低，扩展力强
    */
    public void fead (Ped pet) {
        pet.eat();
    }

}

// 宠物类
public class Pet {
    
    public void eat () {
        System.out.println("宠物在吃饭饭")
    }
}

public class Cat extends Pet{
    
    public void eat () {
        System.out.println("猫在吃饭饭")
    }
}

public class Dog extends Pet{
    
    public void eat () {
        System.out.println("狗在吃饭饭")
    }
}

public class Snake extends Pet{
    
    public void eat () {
        System.out.println("蛇在吃饭饭")
    }
}


public class Test {
    public static void main(String[] args) {
        // 创建主人
        Master m1 = new Master();
        // 主人喂猫
        m1.fead(new Cat());
        
        // 主人喂狗
        m1.fead(new Dog());
        
     	// 主人喂蛇
        m1.fead(new Snake());
    }
}
```



### finall 关键字

> 表示最终的，不可变的。跟 js 中 const 作用有点类似
>
> - final 修饰的类无法被继承
> - final 修饰的方法无法被覆盖
> - final 修饰的变量一旦赋值，不可重新赋值
> - final 修饰的实例变量必须手动赋值，不能默认赋值
> - final 修饰的引用虽然指向某个对象之后不能指向其他对象，但是所指向的对象内部的内存是可以被修改的
> - final 修饰的实例变量，一般和static联合使用，被称为常量

```java

public final class finalTest {
    /*
    	成员变量又默认赋值 + final 修饰的变量一旦赋值就不能重新赋值
    	所以下面语法就是默认值0，不能再重新赋值，变量就没有意义
    */ 
    // final int age; // 编译错误
    // 正确写法1
    final int age = 20;
    
    // 正确写法2
    final age;
    public finalTest() {
        this.age = 20;
    }
    // 上边两种写法本质是一样的，变量的赋值就发生在构造函数执行
    
    
    public static void main(String[] args) {
        
    }
}

// Java 内置的 String 方法为最终方法不能被继承，覆盖，赋值
// 编译错误
public static class myString extends String {}
```



### package，important

> 包又称为package吗Java 中引入这种语法机制主要是为了方便程序员的管理。不同功能的类被分门别类放到不同的软件包当中，查找比较方便，管理比较方便，易维护。



#### **怎么定义 package？**

- 在Java 源程序的第一行上编写 package 语句。

- package 只能编写一个语句

- 语法结构：

	package 包名；



#### **包名的命名规范：**

- 公司域名倒序 + 项目名 + 模块名 + 功能名；

- 采用这种方式重名概率较低。因为公司域名具有全球唯一性。

- 包名要求全部小写，包名也是标识符，必须遵守命令规则

- 一个包将来对应一个目录

```java
package com.bjpowernode.javase.day11.Test01;
```

使用 package 机制后，**java 类名** 中类名 不再是 文件名。而是 com.bjpowernode.javase.day11.Test01;

编译后 需要创建对应目录：com/javase/day11/Test01.class

**另一种方式（编译+运行）**

- javac -d 编译之后存放路径 Java 源文件的路径

	```java
	// eg: 将 F:\Hello.java 文件编译后存放到 C:\com 目录下
	javac -d C:\com F:\Hello.java
	```

- 将当前路径中 *.java 编译之后放到 c:\目录下

	```java
	// JVM 的类加载器 ClassLoader 默认聪当前路径下加载
	javac -d . *.java
	```




#### import

> 当前类中访问其他不同当前目录的的程序时，需要使用import导入其他包中的程序

```java
import com.bjpowernode.javase.test002.Cat;
// 导入 javase 目录 下 test002 包 中的 Cat 类

// 省略写法，表示导入包com.bjpowernode.javase.test002在这个文件中使用到的所有类，不用考虑性能问题
import com.bjpowernode.javase.test002.*
```



### 控制访问权限修饰符

> 访问控制权限修饰符来控制元素访问范围

**访问控制权限修饰符包括：**

- public	表示公开的，在任何位置都可以访问
- protected  同包下，子类中可以访问
- 缺省  同包下可以访问
- private  表示私有的，只能在本类中访问

范围从大到小排序： public > protected > 默认 > private

```java
public class User {
    // 受保护的
    protected int i = 0;
    // 缺省
    int b = 10;
    // 私有的
    private String c = "privateC";
    // 公开的
    public float d = 1.0f;
    
}
```

**类，接口 只能采用 public 和缺省的修饰符进行修饰。【内部类除外】**

```java
public class A {}
class B {}
```

属性 （四个都能用）

方法 （四个都能用）

### super 关键字

> 关键字，全小写
>
> 与 this 对比
>
> this:
>
> 目的：调用本类的方法
>
> - this 能出现在实例构造方法
> - this 的语法是："this." ,"this()"【this() 只能出现在构造方法第一行，目的是构造方法代码复用，通用调用本类其他构造方法】
> - this 不能在静态方法中使用
> - this 大部分情况可以省略（在区分局部变量和成员变量时不能省略）
>
> super:
>
> 目的：创建子类对象的时候，先初始化父类型的特征
>
> - super 能出现在实例构造方法和构造方法中
> - super 的语法是："this." ,"this()"
> - super 不能在静态方法中使用
> - super 只能出现在构造方法第一行，通过当前方法去调用**父类**中其他的构造方法，目的是：代码复用
>
> **this() 和 super() 不能共存**

```java
public class superTest {
    public static viod main(Stirng[] args) {
        // 创建子类对象
        new C();
    }
    
}

class A {
    // 建议手动将一个类的无参构造方法写出来
    public A() {
        // super(); // 这里也是默认的构造方法写出来
        System.out.println("A 类的无参构造方法");//1
    }
}

class B extends A {
    public B() {
        System.out.println("B类的无参数构造方法");//2
    }
    public B(String name) {
        System.out.println("B类的有参数构造方法（String）");//3
    }
}

class C extends B {
    public C () {
        this("zhanggsan");
        System.out.println("C 类的无参数构造方法");//4
    }
    public C(String name) {
        this(name, 20);
        System.out.println("C类的有参数构造方法（String）");//5
    }
    public C(String name, int age) {
        super(name);
        System.out.println("C类的有参数构造方法（String, int）");//6
    }
}

// 执行顺序
13654
```

**调用子类构造方法必然调用父类构造方法**

**在Java语言中不管是new什么对象，最后老祖宗的Object类的无参构造方法（处于栈顶部，最后调用，最先结束）一定会执行**



### 抽象类

> 1. 什么是抽象类？
>
> 	类和类之间具有共同特征，将这些共同特征提取出来，形成的就是抽象类。
>
> 	类本身是不存在的，所以抽象类无法创建对象《无法实例化》
>
> 2. 抽象类属于什么类型？
>
> 	抽象类也属于引用数据类型。
>
> 3. 抽象类怎么定义？
>
> 	语法：
>
> 	​	[修饰符列表] abstract class 类名 {
>
> 	​		类体;
>
> 	​	}
>
> 4. 抽象类无法实例化，无法创建对象，所有它是用来被子类继承的
>
> 	```java
> 	// 银行账户类
> 	abstract class Account {
> 	    
> 	}
> 	
> 	// 子类继承抽象类，子类可以实例化
> 	class CreditAccount extend Account {
> 	    
> 	}
> 	// 抽象类的子类也可以是抽象的类
> 	//abstract class CreditAccount extend Account {}
> 	
> 	CreditAccount c1 = new CreditAccount();
> 	```
>
> 5. 由于final修饰的类不能被继承，所以 final与abstract不能同时出现
>
> 6. 抽象类有构造方法，这个方法提供给子类使用
>
> 7. 抽象方法：表示没有实现的方法，没有方法体的方法
>
> 	特点：
>
> 	- 没有方法体，以分号结尾
> 	- 前面有 abstract 关键字
>
> 	```java
> 	public abstract void dosome();
> 	```
>
> 8. 抽象类中不一定有抽象方法，抽象方法必须出现在抽象类中
>
> 9. 非抽象子类继承抽象类时，会继承抽象方法。但抽象方法只能出现在抽象类中。所以要把子类改为抽象的，或者重写这个继承的抽象方法（也可以叫**实现**）避免编译出错
>
> 	**一个非抽象类继承一个抽相类，非抽象类必须要将抽象方法实现**
>
> 	面向抽象编程：
>
> 	```java
> 	// 动物抽象类
> 	abstract class Animal {
> 	    // 抽象方法
> 	    public abstract void move();
> 	}
> 	
> 	class Bird extends Animal {
> 	    // 实现抽象方法
> 	    public void move() {
> 	        System.out.println("鸟儿在飞！");
> 	    }
> 	}
> 	
> 	public class AbstractTest02 {
> 	    public static void main(String[] args) {
> 	        // 多态：编译是一种状态，运行是另一种状态
> 	        // 父类型引用指向子类型对象
> 	        Animal a = new Bird();// 向上转型
> 	    }
> 	}
> 	```
>
> 	
>
> 
>
> 

![image-20230130154911339](https://raw.githubusercontent.com/wyf195075595/images/main/blog/image-20230130154911339.png)

### 接口

> 1. 接口也是一种引用数据类型
>
> 2. 接口也是完全抽象的（抽象类是半抽象）或者也可以说接口是特殊的抽象类
>
> 3. 接口怎么定义，语法是什么？
>
> 	[修饰符列表] interface 接口名 {}
>
> 	```java
> 	interface A {}
> 	interface B {}
> 	interface C {}
> 	```
>
> 	
>
> 4. 接口支持多继承，一个接口可以继承多个接口
>
> 	```java
> 	interface D extends A,B,C {
> 	    
> 	}
> 	```
>
> 	
>
> 5. 接口中只包含两个部分内容，**常量和抽象方法**
>
> 	```java
> 	interface MyMath {
> 	    public abstract int sum(int a, int b);
> 	    // 省略写法
> 	    // int sum(int a, int b);
> 	}
> 	```
>
> 6. 接口中的抽象方法都是公开的
>
> 7. 接口中的方法都是抽象方法，所以接口中方法都不能有方法体
>
> 8. 接口中的常量不能被修改
>
> 	```java
> 	interface MyMath {
> 	    public static final double PI = 3.1415926;
> 	    // 省略写法
> 	    // double PI = 3.1415926;
> 	}
> 	```
>
> 	

### **接口的基础语法**

```java
interface MyMath {
    double FF = 3.1415926;
    int sum(int a, int b);
    int sub(int a, int b);
}
```



1. 类和类之间叫做继承，类和接口之间叫做实现（也可以看作”继承“）

	继承使用 extends 关键字

	实现使用 implements 关键字

	

2. 当一个**非抽象的类**实现接口的话，必须将接口中所有方法实现

	```java
	public class Test {
	    public static void mian(String[] args) {
	        // 面向接口编程
	        MyMath mm = new MyMathImpl();
	        mm.sum(1,2);
	    }
	}
	
	class MyMathImpl implements MyMath {
	    public int sum(int a, int b) {
	        return a + b;
	    }
	    public int sub(int a, int b) {
	        return a - b;
	    }
	}
	```

3. 一个类可以实现多个接口

	这种机制弥补了Java类只支持单继承带来的缺陷

4. 类型转换

	向下转型养成好习惯，先用 instanceof 判断

	```java
	public class Test {
	    public static class void main(String[] args) {
	        A a = new D();
	        B b = new D();
	        C c = new D();
	        // 多态
	        B b2 = (B)a;
	        // 接口 E，D 没有继承关系，强转时编译不会出错，但是运行时可能出现 ClassCastException 异常
	        E e = (B)a;
	        
	    }
	}
	
	interface A {}
	interface B {}
	interface C {}
	interface E {}
	interface D extends A,B,C {}
	```

5. 继承和实现同时存在

	先继承，再实现。

	```java
	public class Test {
	    public static void main(String[] args) {\
	        // 多态
	        Flyable f = new Cat();
	    }
	}
	
	class Animal {}
	
	// 插拔的是接口，通常提取的是行为动作
	interface Flyable {
	    void fly();
	}
	// 给猫插上翅膀
	class Cat extends Animal implements Flyable {
	    public void fly() {}
	}
	```

	

### 接口在开发中的作用

> 注意：接口在开发中的作用类似于多态在开发中的作用
>
> 多态：面向抽象编程，不要面向具体编程。降低程序耦合度。提高程序拓展力。
>
> 面向接口编程少不了多态（接口+多态才可以达到降低耦合）
>
> 任何一个接口都有调用者和实现者，解耦合是指接触调用者和实现者的耦合

```java
// 顾客
public class Customer {
    FoodMenu foodmenu;
    public Customer() {
        
    }
    public Customer(FoodMenu fm) {
        this.foodmenu = fm;
    }
    // 点菜
    public void order() {
        this.foodmenu.shiZiChaoJiDan();
        this.foodmenu.yuXaingRouSi();
    }
}

// 菜单
interface FoodMenu {
    // 西红柿炒鸡蛋
    void shiZiChaoJiDan();
    // 鱼香肉丝
    void yuXaingRouSi();
}
// 厨师
public class ChinaCooker implements FoodMenu {
    // 西红柿炒鸡蛋
    public void shiZiChaoJiDan() {
        System.out.println("中餐厨师做的西红柿炒鸡蛋");
    }
    // 鱼香肉丝
    public void yuXaingRouSi() {
        System.out.println("中餐厨师做的鱼香肉丝");
    }
}
public class AmericCooker implements FoodMenu {
    // 西红柿炒鸡蛋
    public void shiZiChaoJiDan() {
        System.out.println("西餐厨师做的西红柿炒鸡蛋");
    }
    // 鱼香肉丝
    public void yuXaingRouSi() {
        System.out.println("西餐厨师做的鱼香肉丝");
    }
}

// 测试
public class Test {
    public static void main(String[] args) {
        // 创建厨师
        FoodMenu cc = new ChinaCooker();
        // 创建顾客
        Customer cm = new Customer(cc);
        cm.order();
    }
}
```

### 类型和类型之间的关系

> is a, has a, like a
>
> - is a: 
>
> 	Cat is a Animal（猫是一个动物）
>
> 	凡是满足 is a 的表示 **继承关系**
>
> 	```java
> 	A extends B
> 	```
>
> 	
>
> - has a:
>
> 	I has a Pen （我有一支笔）
>
> 	凡是能满足 has a 关系的表示 **关联关系**
>
> 	关联关系通常以”属性“的形式存在
>
> 	```java
> 	A {
> 	    B b;
> 	}
> 	```
>
> 	
>
> - like a:
>
> 	Cooker like a FoodMemu （厨师像一个菜单一样）
>
> 	凡是能满足 like a 关系的表示 **实现关系**
>
> 	实现关系通常是： 类实现接口
>
> 	```java
> 	A implements B;
> 	```
>
> 	
>
> 



### 抽象类和接口有什么区别？

> 抽象类是半抽象的，接口是完全抽象的
>
> 抽象类中没有构造方法，接口中没有构造方法
>
> 接口之间可以多继承，类之间只能单继承
>
> 一个类可以同时实现多个接口，一个抽象类只能继承一个类
>
> 



## 开发工具 IDE使用

> 快捷键：
>
> 生成**main**方法： psvm
>
> 生成 打印语句：sout
>
> 删除一行：Ctrl + Y
>
> 编辑窗口变大变小：Ctrl + shift + F12
>
> 显示隐藏项目树：alt + 1
>
> 新增/新建/添加快捷键： alt + insert
>
> tab 页切换： alt + 左右箭头
>
> 运行：Ctrl + shift + F10
>
> 纠错： alt + 回车

## UML

> UML 是一种统一建模语言，一种图标式语言，我们可以通过UML来描述一下继承结构。 就像是建筑师的设计图纸





## 源码及API文档

### JDK 类库的根类：Object

> 这些方法是所有子类通用的，任何一个类默认继承object，计算没有直接继承，最终也会默认继承。

有哪些常用的文档？

1. 去源代码查看 【C:\Program Files\Java\jdk1.8.0_321\src】
2. 去查阅Java类库帮助文档

#### toString

> 返回对象的字符串表示形式。类名+@+16进制对象哈希码

```java
getClass().getName() + '@' + Integer.toHexString(hashCode())
    
// 调用
obj.toString()
```



#### equals

> 指示一些其他对象是否等于此对象。

```java
public boolean equals(Object obj) {
    return (this === obj);
}
// 调用
obj1.equals(obj2);
```

默认是通过 == 判断是否相等，== 是判断两个Java对象的内存地址。如果我们需要判断两个对象内容相同则需要重写 equals 方法

#### finalize

> 垃圾回收器负责调用,此方法不需要调用，只要重写即可。带系统执行垃圾回收时会触发这个方法

```java
class Person {
    protected void finalize() throws Throwable {
        System.out.println("即将被销毁！");
    }
}

// 例如：当 
Person p = new Person();
p = null; // 此时会触发 p.finalize()

System.gc();// 手动触发垃圾回收
```

java 中的垃圾回收机制不会轻易启动，jdk9版本后废弃了

#### clone

> 对象的克隆



#### hashCode

> 获取对象哈希值的一个方法，返回值是经过哈希算法转换的数字，等同于内存地址



### 匿名内部类

> **也叫做局部内部类。不推荐使用，但是要看懂别人写的**
>
> 1. 什么是内部类？
>
> 	在类的内部又重新定义了一个类，被称为内部类
>
> 2. 内部类的分类
>
> 	- 静态内部类：类似于静态变量
> 	- 实例内部类：类似于实例变量
> 	- 局部内部类：类似于局部变量

```java
class Test {
    // 静态内部类
    static class Inner1 {}
    // 实例内部类
    class Inner2 {}
    
    public void doSome () {
        // 局部内部类
        class Inner3 {}
    }
}

// 实例化内部类
// new Test().new Inner2();

// 负责计算的接口
interface Compute {
    // 抽象方法啊
    int sum (int a, int b);
}

// 计算的接口需要实现类
class ComputeImpl implements Compute {
    public int sum (int a, int b) {
        return a + b;
    }
}

// 数学类
class MyMath {
    public void sum(Compute c, int x, int y) {
        int rs = c.sum(x, y);
        System.out.println("计算结果:" + rs);
    }
}


class Test {
    public static voidd main(String[] args) {
        MyMath mm = new MyMath();
        
        mm.sum(new ComputeImpl(), 200, 100);
    }
}
```



匿名内部类可以省略 计算的接口需要实现类

```java
// 负责计算的接口
interface Compute {
    // 抽象方法啊
    int sum (int a, int b);
}

// 数学类
class MyMath {
    public void sum(Compute c, int x, int y) {
        int rs = c.sum(x, y);
        System.out.println("计算结果:" + rs);
    }
}


class Test {
    public static voidd main(String[] args) {
        MyMath mm = new MyMath();
        // 使用匿名内部类, 看似是接口可以 new 了，实际上是后面的括号中实现了方法。 【不推荐使用，不能复用，结构不清晰】
        mm.sum(new Compute() {
            public int sum (int a, int b) {
                return a + b;
            }
        }, 200, 100);
    }
}
```

### 数组

> - Java 语言中的数组属于引用数据类型。父类是 Object
>
> - 可以储存 任意数据类型。储存在堆内存，引用类型在数组中存储的是引用 内存地址
>
> - 数组分类：一维，二维，三维，多维数组
> - 数组中元素的类型要求统一【装苹果的数组就不能装香蕉】
>
> 优点：
>
> 1. 检索数据效率最快
> 2. 元素类型相同，所以占用空间相同
> 3. 储存空间是连续的
>
> 缺点：
>
> - 随机增删元素，会影响后边元素向前或向后移动，效率低【对数组最后一个元素增删无影响】
> - 内存中连续的大空间少。无法存储大数据

#### 语法

```java
// 定义
int[] arrar1;
double[] arrar1;
boolean[] arrar1;
Object[] arrar1;

// 初始化
int[] array = {1,2,3,4,5};
// 初始化6个长度的String类型数组,默认值为 null
String[] array1 = new String[6];

// 遍历
for(int i = 0; i <= array.length; i++) {
    // 下标越界异常： ArrayIndexOutOfBoundsException
    array[i];
}

// 传参
public void test(int[] arr) {}

test(array); // √
test({1,2,3,4,5});// ×
test(new int[3]);// √
test(new int[]{1,2,3,4,5});// √

```

#### 主函数 main 的参数

```java
class Test {
    public static voidd main(String[] args) {
        
    }
}

java Test 参数1 参数2 ...
```

#### 扩容

> 数组长度一旦确定就不可变，那数组满了怎么办？
>
> java中的方式：先建一个大容量数组，再将小容量数组中数组一个一个拷贝过去
>
> 结论：效率低，少用

数组拷贝方法：

**System.arraycopy(src, srcPos, dest, destPos, length)**

```java
int[] a1 = {1,2,3,4,5,6,7,8};
int[] a2 = new int[10];
System.arraycopy(a1,0,a2,0,5);

System.out.print(a2[0]+ "" +a2[1]+ "" +a2[2]+ "" +a2[3]+ "" +a2[4]+ "" +a2[5]);
```



#### 二维数组

```java
int[][] a = {
    {1,2,3},
    {1,2,3},
    {1,2,3}
}
```



#### 数组的工具方法

> java.utils.Arrays
>
> 常用的方法，sort, binarySearch【二分法查找】

- binarySearch()

	```java
	// 返回对应下标，没有返回 -1
	Arrays.binarySearch(数组, 查找的值);
	```

	

- sort()



### String

> - 双引号括起来的都是String对象
> - 字符串不可变，不能修改
> - JDK中字符串都是直接存储在**方法区**的**字符串常量池**当中【垃圾回收机制不会回收常量池数据】

```java
/*
一共创建了三个对象：
字符串常量池 ： "hello"
堆内存: s1,s2
*/
String s1 = new String("hello");
String s2 = new String("hello");
```

#### 常用构造方法：

1. ```java
	String s = new String("")
	```

2. ```java
	String s = ""
	```

3. ```java
	String s = new String(char数组)
	```

4. ```java
	String s = new String(char数组,起始下标,长度)
	```

5. ```java
	String s = new String(byte数组)
	```

6. ```java
	String s = new String(byte数组,起始下标,长度)
	```

	

#### chartAt

> 返回指定索引处的 char 值
>
> ```java
> "中国人".charAt(1);// 国
> ```
>
> 

#### compareTo

> 按照字典（ascll码表值）顺序去比较字符串大小.
>
> 前小后大: -1
>
> 前后一致：0
>
> 前大后小：1
>
> ```java
> "abc".compareTo("abce"); // -1
> ```
>
> 

#### contains

> 是否包含某字符串
>
> ```java
> "Hello java".contains("java");// true
> ```
>
> 

#### endsWith

> 是否以某字符串结尾

#### equalsIgnoreCase

> 忽略大小写的比较字符串相等

#### getBytes

> 将字符串对象转为字节数组
>
> ```java
> byte[] bytes = "abcde".getBytes();
> ```
>
> 

#### isEmpty

> 判断某个字符串是否为空

#### toChartArray

> 将字符串转换为char数组

#### valueOf

> 底层调用 toString()

#### indexOf,lastIndexOf

> 某个字符串在当前字符串中第一次/最后一次出现的下标索引



### stringBuffer

> stringBuider 与 stringBuffer 都可以拼接字符串，区别在于前者是线程安全的，后者不是
>
> 用 + 拼接字符串会导致方法区字符串常量池创建多个对象。造成空间浪费

```java
// 创建一个初始化容量为16个byte[] 数组。（字符串缓冲区），创建时可以估计给一个容量（字节）
StringBuffer sb = new StringBuffer(50);
// append 追加字符串底层会扩容
sb.append("我是");
sb.append(300);
System.out.println(sb);// 我是300
```



### 包装类

> Java为8中数据类型提供了8种包装类，父类是Object。
>
> 包装类可以将基本数据类型包装成对象

| 基本数据类型 | 包装类型                              |
| ------------ | ------------------------------------- |
| byte         | java.lang.Byte（父类Number）          |
| short        | java.lang.Short（父类Number）         |
| int          | java.lang.**Integer**（父类Number）   |
| long         | java.lang.Long（父类Number）          |
| float        | java.lang.Float（父类Number）         |
| double       | java.lang.Double（父类Number）        |
| boolean      | java.lang.Boolean（父类Object）       |
| char         | java.lang.**Character**（父类Object） |

包装类还提供了各种类型的拆箱方法，将包装类转为基本数据类型。不过后面都废弃了，jdk1.5后支持了自动装箱拆箱

```java
// 手动装箱
Integer i = new Integer(10);
// 手动拆箱
int ii = i.intValue();

// 自动装箱
Integer x = 10;
// 自动拆箱
int y = x;
```

java 中为了提高程序效率，将 [-128, 127]数字提前包装创建好了，所以这个区间的的数据不在需要new,直接从常量池中获取

```java
Integer a = 128;
Integer b = 128;
a == b;// false

Integer x = 100;
Integer y = 100;
x == y;// true
```

### Number 常用方法

- parseInt	转整形
- 



### 日期处理

> java.utils.Date 对象
>
> 格式化时间的库：java.text.SimpleDateFormat

```java
/*
	yyyy 年
	MM	月
	dd	日
	HH	时
	mm	分
	ss	秒
	sss	毫秒
*/
// Date -> String
Date dt = new Date();
SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:sss");
String time = format.format(dt);
System.out.println(time);// 2023-02-02 09:27:32:032

// String -> date
String dateTime = "2022-12-12 12:12:12";
// 此处格式要和字符串日期格式相同
SimpleDateFormat f2 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
Date rs = f2.parse(dateTime);
System.out.println(rs);

// 时间戳 -> Date
int timestamp = 1675302056747;
Date dt = new Date(timestamp);
SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:sss");
String ddd = format1.format(dt1);
System.out.println("ddd = " + ddd);// 2023-02-02 09:40:56:056
```



### 数字格式化

> java.text.DecimalFormat 类
>
> 格式：
>
> #：代表任意数字
>
> ,：代表千分位
>
> .：代表小数点

```java
double xx = 10023.222502056;
DecimalFormat df = new DecimalFormat("###,###.###");
String rr = df.format(xx);
System.out.println(rr);// 10,023.223
```



### 高精度 BigDecimal

> BigDecimal 属于大数据，精度极高。专门用在财务软件当中

```java
BigDecimal bd1 = new BigDecimal(100);
BigDecimal bd2 = new BigDecimal(100);
// +
bd1.add(bd2);
// 运算都提供了自己的方法
```



### 随机数

> 产生一个int类型取值范围内的数字

```java
Random random = new Random();
// 下一个int 类型的数据是101，表示只能取到100
int num = random.nextInt(101);
```



#### 枚举

> 枚举编译之后也是生成 class 文件
>
> 枚举是一种引用类型
>
> 当一个方法返回结果超过两种且可以一一列举的情况建议使用枚举

```java
public enum Season {
    CHUN,XIA,QIU,DONG
} 
```



### 异常机制

> 当Java程序运行出现不正常的情况时，Java语言会把程序的异常信息输出到控制台。供程序员参考，以对程序经行修改
>
> 所有异常都发生在运行阶段

#### 异常声明

java 内置了异常类，可以通过 创建异常对象 再抛出使用

```java
ArithmeticExcepetion error = new ArithmeticExcepetion("异常信息");
throw error;
```



#### 异常的处理

> 如果这个方法你想让调用者处理标错就throws，否则就 try catch

1. try catch 捕获异常并处理

	- catch 后边小括号中得了类型可以是具体类型，也可以是父类型
	- catch 可以写多个。便于精确处理
	- 编写多个catch 时，捕获错误要从小到大

	```java
	try {
	    ...
	   // return 语句再方法中肯定是 最后执行的，finall 会在return 前执行，不会影响return 的值     
	   return 语句
	} catch(错误1|错误2|错误3 e) {
	    // 多个错误声明 是 jdk8 新特性
	    
	    // 调用此方法，会在控制台打印异常详情，建议使用
	    e.printStackTrace();
	} finally {
	    // 除非 System.exit(0); 推出JVM虚拟机。否则 此处代码一定会执行
	    
	}
	```

	

2. 方法声明位置上，使用 throws 关键字，抛给上一级

	```java
	public class Test {
	    public static void main(String args) {
	        doSome();
	    }
	    public static void doSome() throws 异常1,异常2{
	        int a = 10;
	        int b = 0;
	        int rs = a/b;
	    }
	}
	```



#### 自定义异常

> 业务中的异常很多，内置异常不满足。此时需要自定义异常。
>
> **自定义异常一定要抛出去让调用者处理，否者没有意义**
>
> 异常的应用是代替 return 字符串错误提示

**如何自定义异常？**

1. 编写一个类继承 Exception 或者 RuntimeException
2. 提供两个构造方法，一个无参，一个待用String 参数的

```java
public class MyException extends  Exception {
    public MyException() {
        
    }
    public MyException(String s) {
        super(s);
    }
}

// 使用
MyException mye = new MyException("自定义的错误");
throw mye;
```

